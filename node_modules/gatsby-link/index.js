import _objectWithoutPropertiesLoose from "@babel/runtime/helpers/objectWithoutPropertiesLoose";
import _extends from "@babel/runtime/helpers/extends";
const _excluded = ["to", "getProps", "onClick", "onMouseEnter", "activeClassName", "activeStyle", "innerRef", "partiallyActive", "state", "replace", "_location"];
import PropTypes from "prop-types";
import React from "react";
import { Link, Location } from "@gatsbyjs/reach-router";
import { parsePath } from "./parse-path";
import { isLocalLink } from "./is-local-link";
import { rewriteLinkPath } from "./rewrite-link-path";
export { parsePath };
export function withPrefix(path, prefix = getGlobalBasePrefix()) {
  var _ref;

  if (!isLocalLink(path)) {
    return path;
  }

  if (path.startsWith(`./`) || path.startsWith(`../`)) {
    return path;
  }

  const base = (_ref = prefix !== null && prefix !== void 0 ? prefix : getGlobalPathPrefix()) !== null && _ref !== void 0 ? _ref : `/`;
  return `${base !== null && base !== void 0 && base.endsWith(`/`) ? base.slice(0, -1) : base}${path.startsWith(`/`) ? path : `/${path}`}`;
} // These global values are wrapped in typeof clauses to ensure the values exist.
// This is especially problematic in unit testing of this component.

const getGlobalPathPrefix = () => process.env.NODE_ENV !== `production` ? typeof __PATH_PREFIX__ !== `undefined` ? __PATH_PREFIX__ : undefined : __PATH_PREFIX__;

const getGlobalBasePrefix = () => process.env.NODE_ENV !== `production` ? typeof __BASE_PATH__ !== `undefined` ? __BASE_PATH__ : undefined : __BASE_PATH__;

export function withAssetPrefix(path) {
  return withPrefix(path, getGlobalPathPrefix());
}
const NavLinkPropTypes = {
  activeClassName: PropTypes.string,
  activeStyle: PropTypes.object,
  partiallyActive: PropTypes.bool
}; // Set up IntersectionObserver

const createIntersectionObserver = (el, cb) => {
  const io = new window.IntersectionObserver(entries => {
    entries.forEach(entry => {
      if (el === entry.target) {
        // Check if element is within viewport, remove listener, destroy observer, and run link callback.
        // MSEdge doesn't currently support isIntersecting, so also test for  an intersectionRatio > 0
        cb(entry.isIntersecting || entry.intersectionRatio > 0);
      }
    });
  }); // Add element to the observer

  io.observe(el);
  return {
    instance: io,
    el
  };
};

function GatsbyLinkLocationWrapper(props) {
  return /*#__PURE__*/React.createElement(Location, null, ({
    location
  }) => /*#__PURE__*/React.createElement(GatsbyLink, _extends({}, props, {
    _location: location
  })));
}

class GatsbyLink extends React.Component {
  constructor(props) {
    super(props); // Default to no support for IntersectionObserver

    this.defaultGetProps = ({
      isPartiallyCurrent,
      isCurrent
    }) => {
      if (this.props.partiallyActive ? isPartiallyCurrent : isCurrent) {
        return {
          className: [this.props.className, this.props.activeClassName].filter(Boolean).join(` `),
          style: _extends({}, this.props.style, this.props.activeStyle)
        };
      }

      return null;
    };

    let IOSupported = false;

    if (typeof window !== `undefined` && window.IntersectionObserver) {
      IOSupported = true;
    }

    this.state = {
      IOSupported
    };
    this.abortPrefetch = null;
    this.handleRef = this.handleRef.bind(this);
  }

  _prefetch() {
    let currentPath = window.location.pathname + window.location.search; // reach router should have the correct state

    if (this.props._location && this.props._location.pathname) {
      currentPath = this.props._location.pathname + this.props._location.search;
    }

    const rewrittenPath = rewriteLinkPath(this.props.to, currentPath);
    const parsed = parsePath(rewrittenPath);
    const newPathName = parsed.pathname + parsed.search; // Prefetch is used to speed up next navigations. When you use it on the current navigation,
    // there could be a race-condition where Chrome uses the stale data instead of waiting for the network to complete

    if (currentPath !== newPathName) {
      return ___loader.enqueue(newPathName);
    }

    return undefined;
  }

  componentWillUnmount() {
    if (!this.io) {
      return;
    }

    const {
      instance,
      el
    } = this.io;

    if (this.abortPrefetch) {
      this.abortPrefetch.abort();
    }

    instance.unobserve(el);
    instance.disconnect();
  }

  handleRef(ref) {
    if (this.props.innerRef && Object.prototype.hasOwnProperty.call(this.props.innerRef, `current`)) {
      this.props.innerRef.current = ref;
    } else if (this.props.innerRef) {
      this.props.innerRef(ref);
    }

    if (this.state.IOSupported && ref) {
      // If IO supported and element reference found, setup Observer functionality
      this.io = createIntersectionObserver(ref, inViewPort => {
        if (inViewPort) {
          this.abortPrefetch = this._prefetch();
        } else {
          if (this.abortPrefetch) {
            this.abortPrefetch.abort();
          }
        }
      });
    }
  }

  render() {
    const _this$props = this.props,
          {
      to,
      getProps = this.defaultGetProps,
      onClick,
      onMouseEnter,
      state,
      replace,
      _location
    } = _this$props,
          rest = _objectWithoutPropertiesLoose(_this$props, _excluded);

    if (process.env.NODE_ENV !== `production` && !isLocalLink(to)) {
      console.warn(`External link ${to} was detected in a Link component. Use the Link component only for internal links. See: https://gatsby.dev/internal-links`);
    }

    const prefixedTo = rewriteLinkPath(to, _location.pathname);

    if (!isLocalLink(prefixedTo)) {
      return /*#__PURE__*/React.createElement("a", _extends({
        href: prefixedTo
      }, rest));
    }

    return /*#__PURE__*/React.createElement(Link, _extends({
      to: prefixedTo,
      state: state,
      getProps: getProps,
      innerRef: this.handleRef,
      onMouseEnter: e => {
        if (onMouseEnter) {
          onMouseEnter(e);
        }

        const parsed = parsePath(prefixedTo);

        ___loader.hovering(parsed.pathname + parsed.search);
      },
      onClick: e => {
        if (onClick) {
          onClick(e);
        }

        if (e.button === 0 && // ignore right clicks
        !this.props.target && // let browser handle "target=_blank"
        !e.defaultPrevented && // onClick prevented default
        !e.metaKey && // ignore clicks with modifier keys...
        !e.altKey && !e.ctrlKey && !e.shiftKey) {
          e.preventDefault();
          let shouldReplace = replace;

          const isCurrent = encodeURI(prefixedTo) === _location.pathname;

          if (typeof replace !== `boolean` && isCurrent) {
            shouldReplace = true;
          } // Make sure the necessary scripts and data are
          // loaded before continuing.


          window.___navigate(prefixedTo, {
            state,
            replace: shouldReplace
          });
        }

        return true;
      }
    }, rest));
  }

}

GatsbyLink.propTypes = _extends({}, NavLinkPropTypes, {
  onClick: PropTypes.func,
  to: PropTypes.string.isRequired,
  replace: PropTypes.bool,
  state: PropTypes.object
});
export default /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(GatsbyLinkLocationWrapper, _extends({
  innerRef: ref
}, props)));
export const navigate = (to, options) => {
  window.___navigate(rewriteLinkPath(to, window.location.pathname), options);
};