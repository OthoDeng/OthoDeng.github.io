import _extends from "@babel/runtime/helpers/extends";
import React, { useEffect, useContext } from "react";
import { PartytownContext } from "./partytown-context";
import { requestIdleCallback } from "./request-idle-callback-shim";
export let ScriptStrategy; // eslint-disable-next-line @typescript-eslint/naming-convention

(function (ScriptStrategy) {
  ScriptStrategy["postHydrate"] = "post-hydrate";
  ScriptStrategy["idle"] = "idle";
  ScriptStrategy["offMainThread"] = "off-main-thread";
})(ScriptStrategy || (ScriptStrategy = {}));

const handledProps = new Set([`src`, `strategy`, `dangerouslySetInnerHTML`, `children`, `onLoad`, `onError`]);
export const scriptCache = new Set();
export const scriptCallbackCache = new Map();
export function Script(props) {
  const {
    id,
    src,
    strategy = ScriptStrategy.postHydrate
  } = props || {};
  const {
    collectScript
  } = useContext(PartytownContext);
  useEffect(() => {
    let details;

    switch (strategy) {
      case ScriptStrategy.postHydrate:
        details = injectScript(props);
        break;

      case ScriptStrategy.idle:
        requestIdleCallback(() => {
          details = injectScript(props);
        });
        break;

      case ScriptStrategy.offMainThread:
        if (collectScript) {
          const attributes = resolveAttributes(props);
          collectScript(attributes);
        }

        break;
    }

    return () => {
      const {
        script,
        loadCallback,
        errorCallback
      } = details || {};

      if (loadCallback) {
        script === null || script === void 0 ? void 0 : script.removeEventListener(`load`, loadCallback);
      }

      if (errorCallback) {
        script === null || script === void 0 ? void 0 : script.removeEventListener(`error`, errorCallback);
      }

      script === null || script === void 0 ? void 0 : script.remove();
    };
  }, []);

  if (strategy === ScriptStrategy.offMainThread) {
    const inlineScript = resolveInlineScript(props);
    const attributes = resolveAttributes(props);

    if (typeof window === `undefined`) {
      if (collectScript) {
        collectScript(attributes);
      } else {
        console.warn(`Unable to collect off-main-thread script '${id || src || `no-id-or-src`}' for configuration with Partytown.\nGatsby script components must be used either as a child of your page, in wrapPageElement, or wrapRootElement.\nSee https://gatsby.dev/gatsby-script for more information.`);
      }
    }

    if (inlineScript) {
      return /*#__PURE__*/React.createElement("script", _extends({
        type: "text/partytown",
        "data-strategy": strategy,
        crossOrigin: "anonymous"
      }, attributes, {
        dangerouslySetInnerHTML: {
          __html: resolveInlineScript(props)
        }
      }));
    }

    return /*#__PURE__*/React.createElement("script", _extends({
      type: "text/partytown",
      src: proxyPartytownUrl(src),
      "data-strategy": strategy,
      crossOrigin: "anonymous"
    }, attributes));
  }

  return null;
}

function injectScript(props) {
  const {
    id,
    src,
    strategy = ScriptStrategy.postHydrate,
    onLoad,
    onError
  } = props || {};
  const scriptKey = id || src;
  const callbackNames = [`load`, `error`];
  const currentCallbacks = {
    load: onLoad,
    error: onError
  };

  if (scriptKey) {
    /**
     * If a duplicate script is already loaded/errored, we replay load/error callbacks with the original event.
     * If it's not yet loaded/errored, keep track of callbacks so we can call load/error callbacks for each when the event occurs.
     */
    for (const name of callbackNames) {
      if (currentCallbacks !== null && currentCallbacks !== void 0 && currentCallbacks[name]) {
        var _cachedCallbacks$name;

        const cachedCallbacks = scriptCallbackCache.get(scriptKey) || {};
        const {
          callbacks = []
        } = (cachedCallbacks === null || cachedCallbacks === void 0 ? void 0 : cachedCallbacks[name]) || {};
        callbacks.push(currentCallbacks === null || currentCallbacks === void 0 ? void 0 : currentCallbacks[name]);

        if (cachedCallbacks !== null && cachedCallbacks !== void 0 && (_cachedCallbacks$name = cachedCallbacks[name]) !== null && _cachedCallbacks$name !== void 0 && _cachedCallbacks$name.event) {
          var _currentCallbacks$nam, _cachedCallbacks$name2;

          currentCallbacks === null || currentCallbacks === void 0 ? void 0 : (_currentCallbacks$nam = currentCallbacks[name]) === null || _currentCallbacks$nam === void 0 ? void 0 : _currentCallbacks$nam.call(currentCallbacks, cachedCallbacks === null || cachedCallbacks === void 0 ? void 0 : (_cachedCallbacks$name2 = cachedCallbacks[name]) === null || _cachedCallbacks$name2 === void 0 ? void 0 : _cachedCallbacks$name2.event);
        } else {
          scriptCallbackCache.set(scriptKey, _extends({}, cachedCallbacks, {
            [name]: {
              callbacks
            }
          }));
        }
      }
    } // Avoid injecting duplicate scripts into the DOM


    if (scriptCache.has(scriptKey)) {
      return null;
    }
  }

  const inlineScript = resolveInlineScript(props);
  const attributes = resolveAttributes(props);
  const script = document.createElement(`script`);

  if (id) {
    script.id = id;
  }

  script.dataset.strategy = strategy;

  for (const [key, value] of Object.entries(attributes)) {
    script.setAttribute(key, value);
  }

  if (inlineScript) {
    script.textContent = inlineScript;
  }

  if (src) {
    script.src = src;
  }

  const wrappedCallbacks = {};

  if (scriptKey) {
    // Add listeners on injected scripts so events are cached for use in de-duplicated script callbacks
    for (const name of callbackNames) {
      const wrappedEventCallback = event => onEventCallback(event, scriptKey, name);

      script.addEventListener(name, wrappedEventCallback);
      wrappedCallbacks[`${name}Callback`] = wrappedEventCallback;
    }

    scriptCache.add(scriptKey);
  }

  document.body.appendChild(script);
  return {
    script,
    loadCallback: wrappedCallbacks.loadCallback,
    errorCallback: wrappedCallbacks.errorCallback
  };
}

function resolveInlineScript(props) {
  const {
    dangerouslySetInnerHTML,
    children = ``
  } = props || {};
  const {
    __html: dangerousHTML = ``
  } = dangerouslySetInnerHTML || {};
  return dangerousHTML || children;
}

function resolveAttributes(props) {
  const attributes = {};

  for (const [key, value] of Object.entries(props)) {
    if (handledProps.has(key)) {
      continue;
    }

    attributes[key] = value;
  }

  return attributes;
}

function proxyPartytownUrl(url) {
  if (!url) {
    return undefined;
  }

  return `/__third-party-proxy?url=${encodeURIComponent(url)}`;
}

function onEventCallback(event, scriptKey, eventName) {
  const cachedCallbacks = scriptCallbackCache.get(scriptKey) || {};

  for (const callback of (cachedCallbacks === null || cachedCallbacks === void 0 ? void 0 : (_cachedCallbacks$even = cachedCallbacks[eventName]) === null || _cachedCallbacks$even === void 0 ? void 0 : _cachedCallbacks$even.callbacks) || []) {
    var _cachedCallbacks$even;

    callback(event);
  }

  scriptCallbackCache.set(scriptKey, {
    [eventName]: {
      event
    }
  });
}