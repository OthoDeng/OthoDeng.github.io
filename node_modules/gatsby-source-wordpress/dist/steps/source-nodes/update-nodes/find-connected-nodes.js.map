{"version":3,"file":"find-connected-nodes.js","names":["recursivelySearchForIds","key","value","Array","isArray","dump","map","innerValue","Object","values","entries","findConnectedNodeIds","node","childNodeIds","Set","flattenDeep","filter","id","length"],"sources":["../../../../src/steps/source-nodes/update-nodes/find-connected-nodes.js"],"sourcesContent":["import flattenDeep from \"lodash/flattenDeep\"\nimport { dump } from \"dumper.js\"\n\n// After all nodes are created while building the schema, store possible node type relationships. So for example when building the WpPost type, for every gatsby node discovered as a potential connected node type WpPost's fields, record that in redux as WpPost => [...ConnectedTypeNames].\n\n// when creating or updating a Page incrementally, we should find all connected node ids, check the types of each of those id's, if any connected id type has the current node type as a potential connected node type, AND this node is not a connected node of that node, we should refetch that node in case it's now a connected node.\n\n// So we create a new Page, we then check the connected node id's and determine that one of them is a User type. The User type has Page as a potential connected node. So we check if this node is a connected node of that node. If it's not we can't be sure that that User node isn't missing this node as a connected node. So we refetch the connected node of our Page which is a User. Do this for all connected nodes where we can't find a relationship back.\n\nconst recursivelySearchForIds = ([key, value]) => {\n  if (!key || !value) {\n    return null\n  }\n\n  if (key === `id`) {\n    return value\n  } else if (typeof value === `string` || typeof value === `number`) {\n    return null\n  }\n\n  if (Array.isArray(value)) {\n    dump(key)\n    // loop through each value of the array. If it's an object recurse on it's fields\n    // if it's anything else skip it.\n    value.map(innerValue => {\n      if (innerValue === null) {\n        return null\n      }\n\n      if (key === `id` && typeof innerValue === `string`) {\n        return innerValue\n      }\n\n      if (typeof innerValue === `object`) {\n        return Object.values(innerValue).map(recursivelySearchForIds)\n      }\n\n      return null\n    })\n  } else if (typeof value === `object`) {\n    dump(key)\n    return Object.entries(value).map(recursivelySearchForIds)\n  }\n\n  return null\n}\n\nexport const findConnectedNodeIds = node => {\n  const childNodeIds = [\n    ...new Set(\n      flattenDeep(Object.entries(node).map(recursivelySearchForIds)).filter(\n        id => id !== node.id && !!id\n      )\n    ),\n  ]\n\n  if (!childNodeIds.length) {\n    return null\n  }\n\n  return childNodeIds\n}\n"],"mappings":";;;;;AAAA;AACA;AAEA;;AAEA;;AAEA;;AAEA,MAAMA,uBAAuB,GAAG,CAAC,CAACC,GAAG,EAAEC,KAAK,CAAC,KAAK;EAChD,IAAI,CAACD,GAAG,IAAI,CAACC,KAAK,EAAE;IAClB,OAAO,IAAI;EACb;EAEA,IAAID,GAAG,KAAM,IAAG,EAAE;IAChB,OAAOC,KAAK;EACd,CAAC,MAAM,IAAI,OAAOA,KAAK,KAAM,QAAO,IAAI,OAAOA,KAAK,KAAM,QAAO,EAAE;IACjE,OAAO,IAAI;EACb;EAEA,IAAIC,KAAK,CAACC,OAAO,CAACF,KAAK,CAAC,EAAE;IACxB,IAAAG,YAAI,EAACJ,GAAG,CAAC;IACT;IACA;IACAC,KAAK,CAACI,GAAG,CAACC,UAAU,IAAI;MACtB,IAAIA,UAAU,KAAK,IAAI,EAAE;QACvB,OAAO,IAAI;MACb;MAEA,IAAIN,GAAG,KAAM,IAAG,IAAI,OAAOM,UAAU,KAAM,QAAO,EAAE;QAClD,OAAOA,UAAU;MACnB;MAEA,IAAI,OAAOA,UAAU,KAAM,QAAO,EAAE;QAClC,OAAOC,MAAM,CAACC,MAAM,CAACF,UAAU,CAAC,CAACD,GAAG,CAACN,uBAAuB,CAAC;MAC/D;MAEA,OAAO,IAAI;IACb,CAAC,CAAC;EACJ,CAAC,MAAM,IAAI,OAAOE,KAAK,KAAM,QAAO,EAAE;IACpC,IAAAG,YAAI,EAACJ,GAAG,CAAC;IACT,OAAOO,MAAM,CAACE,OAAO,CAACR,KAAK,CAAC,CAACI,GAAG,CAACN,uBAAuB,CAAC;EAC3D;EAEA,OAAO,IAAI;AACb,CAAC;AAEM,MAAMW,oBAAoB,GAAGC,IAAI,IAAI;EAC1C,MAAMC,YAAY,GAAG,CACnB,GAAG,IAAIC,GAAG,CACR,IAAAC,oBAAW,EAACP,MAAM,CAACE,OAAO,CAACE,IAAI,CAAC,CAACN,GAAG,CAACN,uBAAuB,CAAC,CAAC,CAACgB,MAAM,CACnEC,EAAE,IAAIA,EAAE,KAAKL,IAAI,CAACK,EAAE,IAAI,CAAC,CAACA,EAAE,CAC7B,CACF,CACF;EAED,IAAI,CAACJ,YAAY,CAACK,MAAM,EAAE;IACxB,OAAO,IAAI;EACb;EAEA,OAAOL,YAAY;AACrB,CAAC;AAAA"}