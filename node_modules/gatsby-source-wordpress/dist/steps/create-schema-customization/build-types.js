"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _store = _interopRequireDefault(require("../../store"));
var _transformFields = require("./transform-fields");
var _isExcluded = require("../ingest-remote-schema/is-excluded");
var _helpers = require("./helpers");
const unionType = typeBuilderApi => {
  const {
    schema,
    type,
    pluginOptions
  } = typeBuilderApi;
  const types = type.possibleTypes.filter(possibleType => !(0, _isExcluded.typeIsExcluded)({
    pluginOptions,
    typeName: possibleType.name
  })).map(possibleType => (0, _helpers.buildTypeName)(possibleType.name));
  if (!types || !types.length) {
    return false;
  }
  let unionType = {
    name: (0, _helpers.buildTypeName)(type.name),
    types,
    resolveType: node => {
      if (node.__typename) {
        return (0, _helpers.buildTypeName)(node.__typename);
      }
      return null;
    },
    extensions: {
      infer: false
    }
  };

  // @todo add this as a plugin option
  unionType = (0, _helpers.filterTypeDefinition)(unionType, typeBuilderApi, `UNION`);
  return schema.buildUnionType(unionType);
};
const interfaceType = typeBuilderApi => {
  const {
    type,
    schema
  } = typeBuilderApi;
  const state = _store.default.getState();
  const {
    ingestibles
  } = state.remoteSchema;
  const {
    nodeInterfaceTypes
  } = ingestibles;
  const implementingTypes = (0, _helpers.getTypesThatImplementInterfaceType)(type);
  const transformedFields = (0, _transformFields.transformFields)({
    parentInterfacesImplementingTypes: implementingTypes,
    parentType: type,
    fields: type.fields
  });
  if (!transformedFields) {
    return null;
  }
  let typeDef = {
    name: (0, _helpers.buildTypeName)(type.name),
    fields: transformedFields,
    extensions: {
      infer: false
    }
  };

  // this is a regular interface type, not a node interface type so we need to resolve the type name
  if (!nodeInterfaceTypes.includes(type.name)) {
    typeDef.resolveType = node => node !== null && node !== void 0 && node.__typename ? (0, _helpers.buildTypeName)(node.__typename) : null;
  }
  typeDef = (0, _helpers.filterTypeDefinition)(typeDef, typeBuilderApi, `INTERFACE`);
  return schema.buildInterfaceType(typeDef);
};
const objectType = typeBuilderApi => {
  var _type$interfaces;
  const {
    type,
    gatsbyNodeTypes,
    fieldAliases,
    fieldBlacklist,
    schema
  } = typeBuilderApi;
  const transformedFields = (0, _transformFields.transformFields)({
    fields: type.fields,
    parentType: type,
    gatsbyNodeTypes,
    fieldAliases,
    fieldBlacklist
  });

  // if all child fields are excluded, this type shouldn't exist.
  // check null first, otherwise cause:
  // TypeError: Cannot convert undefined or null to object at Function.keys (<anonymous>)
  // Also cause wordpress blog site build failure in createSchemaCustomization step
  if (!transformedFields || !Object.keys(transformedFields).length) {
    return false;
  }
  let objectType = {
    name: (0, _helpers.buildTypeName)(type.name),
    fields: transformedFields,
    description: type.description,
    extensions: {
      infer: false
    }
  };
  if ((_type$interfaces = type.interfaces) !== null && _type$interfaces !== void 0 && _type$interfaces.includes(`Node`)) {
    objectType.interfaces = [`Node`];
  }

  // @todo add this as a plugin option
  objectType = (0, _helpers.filterTypeDefinition)(objectType, typeBuilderApi, `OBJECT`);
  return schema.buildObjectType(objectType);
};
const enumType = ({
  schema,
  type
}) => schema.buildEnumType({
  name: (0, _helpers.buildTypeName)(type.name),
  values: type.enumValues.reduce((accumulator, {
    name
  }) => {
    accumulator[name] = {
      name
    };
    return accumulator;
  }, {}),
  description: type.description
});
var _default = {
  unionType,
  interfaceType,
  objectType,
  enumType
};
exports.default = _default;
//# sourceMappingURL=build-types.js.map