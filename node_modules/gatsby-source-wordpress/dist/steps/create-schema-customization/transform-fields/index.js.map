{"version":3,"file":"index.js","names":["handleCustomScalars","field","fieldTypeIsACustomScalar","type","kind","typeIsASupportedScalar","name","fieldTypeOfTypeIsACustomScalar","ofType","getAliasedFieldName","fieldAliases","returnAliasedFieldName","fieldIsExcluded","fieldName","thisTypeSettings","fieldBlacklist","parentTypeSettings","parentInterfacesImplementingTypeSettings","fieldOfTypeWasFetched","excludeFieldNames","includes","find","typeSetting","excludedFieldName","exclude","args","arg","findNamedTypeName","transformFields","fields","parentType","parentInterfacesImplementingTypes","peek","length","gatsbyNodeTypes","getGatsbyNodeTypeNames","store","getState","remoteSchema","getTypeSettingsByType","map","transformedFields","reduce","fieldsObject","typeMap","get","includedChildFields","filter","childFieldTypeSettings","Array","isArray","transform","description","fieldTransformers","test","transformerApi","transformedField","resolve","buildDefaultResolver","Object","keys"],"sources":["../../../../src/steps/create-schema-customization/transform-fields/index.js"],"sourcesContent":["import { fieldTransformers } from \"./field-transformers\"\nimport { getGatsbyNodeTypeNames } from \"../../source-nodes/fetch-nodes/fetch-nodes\"\nimport store from \"~/store\"\n\nimport {\n  fieldOfTypeWasFetched,\n  typeIsASupportedScalar,\n  getTypeSettingsByType,\n  findNamedTypeName,\n} from \"../helpers\"\n\nimport { buildDefaultResolver } from \"./default-resolver\"\n\nconst handleCustomScalars = field => {\n  const fieldTypeIsACustomScalar =\n    field.type.kind === `SCALAR` && !typeIsASupportedScalar(field.type)\n\n  if (fieldTypeIsACustomScalar) {\n    // if this field is an unsupported custom scalar,\n    // type it as JSON\n    field.type.name = `JSON`\n  }\n\n  const fieldTypeOfTypeIsACustomScalar =\n    field.type.ofType &&\n    field.type.ofType.kind === `SCALAR` &&\n    !typeIsASupportedScalar(field.type)\n\n  if (fieldTypeOfTypeIsACustomScalar) {\n    // if this field is an unsupported custom scalar,\n    // type it as JSON\n    field.type.ofType.name = `JSON`\n  }\n\n  return field\n}\n\n// this is used to alias fields that conflict with Gatsby node fields\n// for ex Gatsby and WPGQL both have a `parent` field\nexport const getAliasedFieldName = ({ fieldAliases, field }) =>\n  fieldAliases && fieldAliases[field.name]\n    ? fieldAliases[field.name]\n    : field.name\n\nexport const returnAliasedFieldName = ({ fieldAliases, field }) =>\n  fieldAliases && fieldAliases[field.name]\n    ? `${fieldAliases[field.name]}: ${field.name}`\n    : field.name\n\nconst fieldIsExcluded = ({\n  field,\n  fieldName,\n  thisTypeSettings,\n  fieldBlacklist,\n  parentTypeSettings,\n  parentInterfacesImplementingTypeSettings,\n}) =>\n  // this field wasn't previously fetched, so we shouldn't\n  // add it to our schema\n  (!fieldOfTypeWasFetched(field.type) && fieldName !== `id`) ||\n  // this field was excluded on its parent fields Type\n  (parentTypeSettings.excludeFieldNames &&\n    parentTypeSettings.excludeFieldNames.includes(fieldName)) ||\n  // this field is on an interface type and one of the implementing types has this field excluded on it.\n  (parentInterfacesImplementingTypeSettings &&\n    parentInterfacesImplementingTypeSettings.find(\n      typeSetting =>\n        typeSetting.excludeFieldNames &&\n        typeSetting.excludeFieldNames.find(\n          excludedFieldName => fieldName === excludedFieldName\n        )\n    )) ||\n  // the type of this field was excluded via plugin options\n  thisTypeSettings.exclude ||\n  // field is blacklisted\n  fieldBlacklist.includes(fieldName) ||\n  // this field has required input args\n  (field.args && field.args.find(arg => arg.type.kind === `NON_NULL`)) ||\n  // this field has no typeName\n  !findNamedTypeName(field.type)\n\n/**\n * Transforms fields from the WPGQL schema to work in the Gatsby schema\n * with proper node linking and type namespacing\n * also filters out unusable fields and types\n */\nexport const transformFields = ({\n  fields,\n  parentType,\n  parentInterfacesImplementingTypes,\n  peek = false,\n}) => {\n  if (!fields || !fields.length) {\n    return null\n  }\n\n  const gatsbyNodeTypes = getGatsbyNodeTypeNames()\n\n  const { fieldAliases, fieldBlacklist } = store.getState().remoteSchema\n\n  const parentTypeSettings = getTypeSettingsByType(parentType)\n\n  const parentInterfacesImplementingTypeSettings =\n    parentInterfacesImplementingTypes\n      ? parentInterfacesImplementingTypes.map(type =>\n          getTypeSettingsByType(type)\n        )\n      : null\n\n  const transformedFields = fields.reduce((fieldsObject, field) => {\n    // if there's no field name this field is unusable\n    if (field.name === ``) {\n      return fieldsObject\n    }\n\n    const thisTypeSettings = getTypeSettingsByType(field.type)\n\n    const fieldName = getAliasedFieldName({ fieldAliases, field })\n\n    if (\n      fieldIsExcluded({\n        field,\n        fieldName,\n        thisTypeSettings,\n        fieldBlacklist,\n        parentTypeSettings,\n        parentInterfacesImplementingTypeSettings,\n      })\n    ) {\n      return fieldsObject\n    }\n\n    const { typeMap } = store.getState().remoteSchema\n\n    const type = typeMap.get(findNamedTypeName(field.type))\n\n    const includedChildFields = type?.fields?.filter(field => {\n      const childFieldTypeSettings = getTypeSettingsByType(field.type)\n      const fieldName = getAliasedFieldName({ fieldAliases, field })\n      return !fieldIsExcluded({\n        field,\n        fieldName,\n        thisTypeSettings: childFieldTypeSettings,\n        fieldBlacklist,\n        parentTypeSettings: thisTypeSettings,\n        parentInterfacesImplementingTypeSettings,\n      })\n    })\n\n    // if the child fields of this field are all excluded,\n    // we shouldn't add this field\n    // @todo move this to a central location.\n    // if a type is missing all it's child fields due to exclusion\n    // it should be globally excluded automatically.\n    if (Array.isArray(includedChildFields) && !includedChildFields.length) {\n      return fieldsObject\n    }\n\n    field = handleCustomScalars(field)\n\n    const { transform, description } =\n      peek === false\n        ? fieldTransformers.find(({ test }) => test(field)) || {}\n        : {}\n\n    if (transform && typeof transform === `function` && peek === false) {\n      const transformerApi = {\n        field,\n        fieldsObject,\n        fieldName,\n        gatsbyNodeTypes,\n        description,\n      }\n\n      let transformedField = transform(transformerApi)\n\n      // add default resolver\n      if (typeof transformedField === `string`) {\n        // we need to add a custom resolver to override the default resolver\n        // and check for aliased fields\n        // fields are aliased automatically if they have conflicting types\n        // with other fields of the same name when placed in side-by-side\n        // inlineFragments on the same union or interface type.\n        transformedField = {\n          type: transformedField,\n          resolve: buildDefaultResolver(transformerApi),\n          description: field.description,\n        }\n      } else {\n        transformedField.description = field.description\n      }\n\n      fieldsObject[fieldName] = transformedField\n    } else if (peek) {\n      fieldsObject[fieldName] = true\n    }\n\n    return fieldsObject\n  }, {})\n\n  if (!Object.keys(transformedFields).length) {\n    return null\n  }\n\n  return transformedFields\n}\n"],"mappings":"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"}