{"version":3,"file":"recursively-transform-fields.js","names":["transformInlineFragments","possibleTypes","gatsbyNodesInfo","typeMap","maxDepth","parentType","mainType","parentField","fragments","circularQueryLimit","buildGatsbyNodeFields","depth","buildingFragment","ancestorTypeNames","parentAncestorTypeNames","state","store","getState","remoteSchema","pluginOptions","gatsbyApi","schema","queryDepth","transformedInlineFragments","map","possibleType","type","get","name","typeSettings","getTypeSettingsByType","exclude","dispatch","addFetchedType","isAGatsbyNode","typeNames","includes","fields","typeInfo","filteredFields","kind","filter","filteredField","find","recursivelyTransformFields","length","Boolean","countIncarnations","typeName","ancestorTypeName","transformField","field","fieldBlacklist","fieldAliases","findNamedTypeName","typeKind","findTypeKind","typeIncarnationCount","createFragment","fieldName","returnAliasedFieldName","args","arg","fieldType","ofType","isListOfGatsbyNodes","isListOfMediaItems","hasIdField","listOfType","transformedFields","inlineFragments","every","parentFieldName","previouslyCreatedFragment","fragmentFields","reduce","fieldTypeName","innerFieldField","transformedField","push","queryType","transformFields","fieldIsExcludedOnParentType","fieldIsExcludedOnAll","fragment","fragmentField","internalType","fieldInlineFragment","fragmentInlineFragment","fieldTypeKind","fieldOfTypeKind","typeKindsRequiringSelectionSets","fieldNeedsSelectionSet","grandParentTypeName","recursivelyTransformedFields"],"sources":["../../../../src/steps/ingest-remote-schema/build-queries-from-introspection/recursively-transform-fields.js"],"sourcesContent":["import store from \"~/store\"\nimport {\n  getTypeSettingsByType,\n  findNamedTypeName,\n  findTypeKind,\n} from \"~/steps/create-schema-customization/helpers\"\nimport {\n  fieldIsExcludedOnParentType,\n  fieldIsExcludedOnAll,\n} from \"~/steps/ingest-remote-schema/is-excluded\"\nimport { returnAliasedFieldName } from \"~/steps/create-schema-customization/transform-fields\"\n\nexport const transformInlineFragments = ({\n  possibleTypes,\n  gatsbyNodesInfo,\n  typeMap,\n  maxDepth,\n  parentType,\n  mainType,\n  parentField,\n  fragments,\n  circularQueryLimit,\n  buildGatsbyNodeFields = false,\n  depth = 0,\n  buildingFragment = false,\n  ancestorTypeNames: parentAncestorTypeNames = [],\n}) => {\n  const state = store.getState()\n\n  if (!typeMap) {\n    typeMap = state.remoteSchema.typeMap\n  }\n\n  const { pluginOptions } = state.gatsbyApi\n\n  if (!maxDepth) {\n    maxDepth = pluginOptions.schema.queryDepth\n  }\n\n  if (!circularQueryLimit) {\n    circularQueryLimit = pluginOptions.circularQueryLimit\n  }\n\n  if (!gatsbyNodesInfo) {\n    gatsbyNodesInfo = state.remoteSchema.gatsbyNodesInfo\n  }\n\n  const ancestorTypeNames = [...parentAncestorTypeNames]\n\n  const transformedInlineFragments = possibleTypes\n    .map(possibleType => {\n      possibleType = { ...possibleType }\n\n      const type = typeMap.get(possibleType.name)\n\n      if (!type) {\n        return false\n      }\n\n      const typeSettings = getTypeSettingsByType(type)\n\n      if (typeSettings.exclude) {\n        return false\n      }\n\n      possibleType.type = { ...type }\n\n      // save this type so we can use it in schema customization\n      store.dispatch.remoteSchema.addFetchedType(type)\n\n      const isAGatsbyNode = gatsbyNodesInfo.typeNames.includes(\n        possibleType.name\n      )\n\n      if (isAGatsbyNode && !buildGatsbyNodeFields) {\n        // we use the id to link to the top level Gatsby node\n        possibleType.fields = [`id`]\n        return possibleType\n      }\n\n      const typeInfo = typeMap.get(possibleType.name)\n\n      let filteredFields = [...typeInfo.fields]\n\n      if (parentType?.kind === `INTERFACE`) {\n        // remove any fields from our fragment if the parent type already has them as shared fields\n        filteredFields = filteredFields.filter(\n          filteredField =>\n            !parentType.fields.find(\n              parentField => parentField.name === filteredField.name\n            )\n        )\n      }\n\n      if (typeInfo) {\n        const fields = recursivelyTransformFields({\n          fields: filteredFields,\n          parentType: type,\n          depth,\n          ancestorTypeNames,\n          fragments,\n          buildingFragment,\n          circularQueryLimit,\n          mainType,\n          parentField,\n        })\n\n        if (!fields || !fields.length) {\n          return false\n        }\n\n        possibleType.fields = [...fields]\n        return possibleType\n      }\n\n      return false\n    })\n    .filter(Boolean)\n\n  return possibleTypes && depth <= maxDepth ? transformedInlineFragments : null\n}\n\n// since we're counting circular types that may be on fields many levels up, incarnation felt like it works here ;) the types are born again in later generations\nconst countIncarnations = ({ typeName, ancestorTypeNames }) =>\n  ancestorTypeNames.length\n    ? ancestorTypeNames.filter(\n        ancestorTypeName => ancestorTypeName === typeName\n      )?.length\n    : 0\n\nexport function transformField({\n  field,\n  gatsbyNodesInfo,\n  typeMap,\n  maxDepth,\n  depth,\n  fieldBlacklist,\n  fieldAliases,\n  ancestorTypeNames: parentAncestorTypeNames,\n  circularQueryLimit,\n  fragments,\n  buildingFragment,\n  mainType,\n} = {}) {\n  const ancestorTypeNames = [...parentAncestorTypeNames]\n\n  // we're potentially infinitely recursing when fields are connected to other types that have fields that are connections to other types\n  //  so we need a maximum limit for that\n  if (depth > maxDepth) {\n    return false\n  }\n\n  depth++\n\n  // if the field has no type we can't use it.\n  if (!field || !field.type) {\n    return false\n  }\n\n  const typeSettings = getTypeSettingsByType(field.type)\n\n  if (typeSettings.exclude) {\n    return false\n  }\n\n  // count the number of times this type has appeared as an ancestor of itself\n  // somewhere up the tree\n  const typeName = findNamedTypeName(field.type)\n  const typeKind = findTypeKind(field.type)\n\n  const typeIncarnationCount = countIncarnations({\n    typeName,\n    ancestorTypeNames,\n  })\n\n  if (typeIncarnationCount > 0) {\n    // this type is nested within itself atleast once\n    // create a fragment here that can be reused\n    createFragment({\n      fields: typeMap.get(typeName).fields,\n      type: field.type,\n      fragments,\n      field,\n      ancestorTypeNames: parentAncestorTypeNames,\n      depth,\n      fieldBlacklist,\n      fieldAliases,\n      typeMap,\n      gatsbyNodesInfo,\n      circularQueryLimit,\n      queryDepth: maxDepth,\n      buildingFragment,\n      mainType,\n    })\n  }\n\n  if (typeIncarnationCount >= circularQueryLimit) {\n    return false\n  }\n\n  // this is used to alias fields that conflict with Gatsby node fields\n  // for ex Gatsby and WPGQL both have a `parent` field\n  const fieldName = returnAliasedFieldName({ fieldAliases, field })\n\n  if (\n    fieldBlacklist.includes(field.name) ||\n    fieldBlacklist.includes(fieldName)\n  ) {\n    return false\n  }\n\n  // remove fields that have required args. They'll cause query errors if omitted\n  //  and we can't determine how to use those args programatically.\n  if (\n    field.args &&\n    field.args.length &&\n    field.args.find(arg => arg?.type?.kind === `NON_NULL`)\n  ) {\n    return false\n  }\n\n  const fieldType = typeMap.get(findNamedTypeName(field.type)) || {}\n  const ofType = typeMap.get(findNamedTypeName(fieldType.ofType)) || {}\n\n  if (\n    fieldType.kind === `SCALAR` ||\n    fieldType.kind === `ENUM` ||\n    (fieldType.kind === `NON_NULL` && ofType.kind === `SCALAR`) ||\n    (fieldType.kind === `LIST` && fieldType.ofType.kind === `SCALAR`) ||\n    // a list of enums has no type name, so findNamedTypeName above finds the enum type\n    // instead of the field type. Need to explicitly check here\n    // instead of using helpers\n    (field.type.kind === `LIST` && field.type?.ofType?.kind === `ENUM`)\n  ) {\n    return {\n      fieldName,\n      fieldType,\n    }\n  }\n\n  const isListOfGatsbyNodes =\n    ofType && gatsbyNodesInfo.typeNames.includes(typeName)\n\n  const isListOfMediaItems = ofType && typeName === `MediaItem`\n\n  const hasIdField = fieldType?.fields?.find(({ name }) => name === `id`)\n  if (\n    fieldType.kind === `LIST` &&\n    isListOfGatsbyNodes &&\n    !isListOfMediaItems &&\n    hasIdField\n  ) {\n    return {\n      fieldName: fieldName,\n      fields: [`__typename`, `id`],\n      fieldType,\n    }\n  } else if (fieldType.kind === `LIST` && isListOfMediaItems && hasIdField) {\n    return {\n      fieldName: fieldName,\n      fields: [`__typename`, `id`],\n      fieldType,\n    }\n  } else if (fieldType.kind === `LIST`) {\n    const listOfType = typeMap.get(findNamedTypeName(fieldType))\n\n    const transformedFields = recursivelyTransformFields({\n      fields: listOfType.fields,\n      parentType: listOfType || fieldType,\n      depth,\n      ancestorTypeNames,\n      fragments,\n      circularQueryLimit,\n      buildingFragment,\n      mainType,\n    })\n\n    const transformedInlineFragments = transformInlineFragments({\n      possibleTypes: listOfType.possibleTypes,\n      parentType: listOfType || fieldType,\n      parentField: field,\n      mainType,\n      gatsbyNodesInfo,\n      typeMap,\n      depth,\n      maxDepth,\n      ancestorTypeNames,\n      fragments,\n      circularQueryLimit,\n      buildingFragment,\n    })\n\n    if (!transformedFields?.length && !transformedInlineFragments?.length) {\n      return false\n    }\n\n    // if we have either inlineFragments or fields\n    return {\n      fieldName: fieldName,\n      fields: transformedFields,\n      inlineFragments: transformedInlineFragments,\n      fieldType,\n    }\n  }\n\n  const isAGatsbyNode =\n    // if this is a gatsby node type\n    gatsbyNodesInfo.typeNames.includes(typeName) ||\n    // or all possible types on this type are Gatsby node types\n    typeMap\n      .get(typeName)\n      ?.possibleTypes?.every(possibleType =>\n        gatsbyNodesInfo.typeNames.includes(possibleType.name)\n      )\n\n  if (isAGatsbyNode && hasIdField) {\n    return {\n      fieldName: fieldName,\n      fields: [`__typename`, `id`],\n      fieldType,\n    }\n  }\n\n  const typeInfo = typeMap.get(findNamedTypeName(fieldType))\n\n  const { fields } = typeInfo || {}\n\n  let transformedInlineFragments\n\n  if (typeInfo.possibleTypes) {\n    transformedInlineFragments = transformInlineFragments({\n      possibleTypes: typeInfo.possibleTypes,\n      parentType: typeInfo,\n      parentField: field,\n      mainType,\n      gatsbyNodesInfo,\n      typeMap,\n      depth,\n      maxDepth,\n      ancestorTypeNames,\n      fragments,\n      circularQueryLimit,\n      buildingFragment,\n    })\n  }\n\n  if (fields || transformedInlineFragments) {\n    const transformedFields = recursivelyTransformFields({\n      parentType: typeInfo,\n      parentFieldName: field.name,\n      mainType,\n      fields,\n      depth,\n      ancestorTypeNames,\n      parentField: field,\n      fragments,\n      circularQueryLimit,\n      buildingFragment,\n    })\n\n    if (!transformedFields?.length && !transformedInlineFragments?.length) {\n      return false\n    }\n\n    return {\n      fieldName: fieldName,\n      fields: transformedFields,\n      inlineFragments: transformedInlineFragments,\n      fieldType,\n    }\n  }\n\n  if (fieldType.kind === `UNION`) {\n    const typeInfo = typeMap.get(fieldType.name)\n\n    const transformedFields = recursivelyTransformFields({\n      fields: typeInfo.fields,\n      parentType: fieldType,\n      mainType,\n      depth,\n      ancestorTypeNames,\n      fragments,\n      circularQueryLimit,\n      buildingFragment,\n    })\n\n    const inlineFragments = transformInlineFragments({\n      possibleTypes: typeInfo.possibleTypes,\n      gatsbyNodesInfo,\n      typeMap,\n      mainType,\n      depth,\n      maxDepth,\n      ancestorTypeNames,\n      parentField: field,\n      fragments,\n      circularQueryLimit,\n      buildingFragment,\n    })\n\n    return {\n      fieldName: fieldName,\n      fields: transformedFields,\n      inlineFragments,\n      fieldType,\n    }\n  }\n\n  return false\n}\n\nconst createFragment = ({\n  fields,\n  field,\n  type,\n  fragments,\n  fieldBlacklist,\n  fieldAliases,\n  typeMap,\n  gatsbyNodesInfo,\n  queryDepth,\n  ancestorTypeNames,\n  mainType,\n  buildingFragment = false,\n}) => {\n  const typeName = findNamedTypeName(type)\n\n  if (buildingFragment) {\n    // this fragment is inside a fragment that's already being built so we should exit\n    return null\n  }\n\n  const previouslyCreatedFragment = fragments?.[typeName]\n\n  if (previouslyCreatedFragment && buildingFragment === typeName) {\n    return previouslyCreatedFragment\n  }\n\n  const fragmentFields = fields.reduce((fragmentFields, field) => {\n    const fieldTypeName = findNamedTypeName(field.type)\n    const fieldType = typeMap.get(fieldTypeName)\n\n    if (\n      // if this field is a different type than the fragment but has a field of the same type as the fragment,\n      // we need to skip this field in the fragment to prevent nesting this type in itself a level down\n      fieldType.name !== typeName &&\n      fieldType?.fields?.find(\n        innerFieldField => findNamedTypeName(innerFieldField.type) === typeName\n      )\n    ) {\n      return fragmentFields\n    }\n\n    const transformedField = transformField({\n      field,\n      gatsbyNodesInfo,\n      typeMap,\n      maxDepth: queryDepth,\n      depth: 0,\n      fieldBlacklist,\n      fieldAliases,\n      ancestorTypeNames,\n      mainType,\n      circularQueryLimit: 1,\n      fragments,\n      buildingFragment: typeName,\n    })\n\n    if (findNamedTypeName(field.type) !== typeName && !!transformedField) {\n      fragmentFields.push(transformedField)\n    }\n\n    return fragmentFields\n  }, [])\n\n  const queryType = typeMap.get(typeName)\n\n  const transformedInlineFragments = queryType?.possibleTypes?.length\n    ? transformInlineFragments({\n        possibleTypes: queryType.possibleTypes,\n        parentType: queryType,\n        parentField: field,\n        mainType,\n        gatsbyNodesInfo,\n        typeMap,\n        depth: 0,\n        maxDepth: queryDepth,\n        circularQueryLimit: 1,\n        ancestorTypeNames,\n        fragments,\n        buildingFragment: typeName,\n      })\n    : null\n\n  if (fragments) {\n    fragments[typeName] = {\n      name: `${typeName}Fragment`,\n      type: typeName,\n      fields: fragmentFields,\n      inlineFragments: transformedInlineFragments,\n    }\n  }\n\n  return fragmentFields\n}\n\nconst transformFields = ({\n  fields,\n  parentType,\n  mainType,\n  fragments,\n  parentField,\n  ancestorTypeNames,\n  depth,\n  fieldBlacklist,\n  fieldAliases,\n  typeMap,\n  gatsbyNodesInfo,\n  queryDepth,\n  circularQueryLimit,\n  pluginOptions,\n  buildingFragment,\n}) =>\n  fields\n    ?.filter(\n      field =>\n        !fieldIsExcludedOnParentType({\n          field,\n          parentType,\n        }) &&\n        !fieldIsExcludedOnAll({\n          pluginOptions,\n          field,\n        })\n    )\n    .map(field => {\n      const transformedField = transformField({\n        maxDepth: queryDepth,\n        gatsbyNodesInfo,\n        fieldBlacklist,\n        fieldAliases,\n        typeMap,\n        field,\n        depth,\n        ancestorTypeNames,\n        circularQueryLimit,\n        fragments,\n        buildingFragment,\n        mainType,\n        parentField,\n      })\n\n      if (transformedField) {\n        // save this type so we know to use it in schema customization\n        store.dispatch.remoteSchema.addFetchedType(field.type)\n      }\n\n      const typeName = findNamedTypeName(field.type)\n      const fragment = fragments?.[typeName]\n\n      // @todo add any adjacent fields and inline fragments directly to the stored fragment object so this logic can be changed to if (fragment) useTheFragment()\n      // once that's done it can be added above and below transformField() above ☝️\n      // and potentially short circuit expensive work that will be thrown away anyway\n      if (fragment && transformedField && buildingFragment !== typeName) {\n        // if (fragment && buildingFragment !== typeName && transformedField) {\n        // remove fields from this query that already exist in the fragment\n        if (transformedField?.fields?.length) {\n          transformedField.fields = transformedField.fields.filter(\n            field =>\n              !fragment.fields.find(\n                fragmentField => fragmentField.fieldName === field.fieldName\n              )\n          )\n        }\n\n        // if this field has no fields (because it has inline fragments only)\n        // we need to create an empty array since we treat reusable fragments as\n        // a field\n        if (!transformedField.fields) {\n          transformedField.fields = []\n        }\n\n        transformedField.fields.push({\n          internalType: `Fragment`,\n          fragment,\n        })\n\n        if (transformedField?.inlineFragments?.length) {\n          transformedField.inlineFragments =\n            transformedField.inlineFragments.filter(\n              fieldInlineFragment =>\n                // yes this is a horrible use of .find(). @todo refactor this for better perf\n                !fragment.inlineFragments.find(\n                  fragmentInlineFragment =>\n                    fragmentInlineFragment.name === fieldInlineFragment.name\n                )\n            )\n        }\n      }\n\n      if (field.fields && !transformedField) {\n        return null\n      }\n\n      const fieldTypeKind = findTypeKind(field.type)\n      const fieldOfTypeKind = findTypeKind(field.type.ofType)\n      const typeKindsRequiringSelectionSets = [`OBJECT`, `UNION`, `INTERFACE`]\n      const fieldNeedsSelectionSet =\n        typeKindsRequiringSelectionSets.includes(fieldTypeKind) ||\n        typeKindsRequiringSelectionSets.includes(fieldOfTypeKind)\n\n      if (\n        // if our field needs a selectionset\n        fieldNeedsSelectionSet &&\n        // but we have no fields\n        !transformedField.fields &&\n        // and no inline fragments\n        !transformedField.inlineFragments\n      ) {\n        // we need to discard this field to prevent GraphQL errors\n        // we're likely at the very bottom of the query depth\n        // so that this fields children were omitted\n        return null\n      }\n\n      return transformedField\n    })\n    .filter(Boolean)\n\nconst recursivelyTransformFields = ({\n  fields,\n  parentType,\n  mainType,\n  fragments,\n  parentField,\n  ancestorTypeNames: parentAncestorTypeNames,\n  depth = 0,\n  buildingFragment = false,\n}) => {\n  if (!fields || !fields.length) {\n    return null\n  }\n\n  if (!parentAncestorTypeNames) {\n    parentAncestorTypeNames = []\n  }\n\n  const ancestorTypeNames = [...parentAncestorTypeNames]\n\n  const {\n    gatsbyApi: { pluginOptions },\n    remoteSchema: { fieldBlacklist, fieldAliases, typeMap, gatsbyNodesInfo },\n  } = store.getState()\n\n  const {\n    schema: { queryDepth, circularQueryLimit },\n  } = pluginOptions\n\n  if (depth > queryDepth && ancestorTypeNames.length) {\n    return null\n  }\n\n  const typeName = findNamedTypeName(parentType)\n\n  const grandParentTypeName = ancestorTypeNames.length\n    ? ancestorTypeNames[ancestorTypeNames.length - 1]\n    : null\n\n  if (grandParentTypeName && typeName !== grandParentTypeName) {\n    // if a field has fields of the same type as the field above it\n    // we shouldn't fetch them. 2 types that are circular between each other\n    // are dangerous as they will generate very large queries and fetch data we don't need\n    // these types should instead be proper connections so we can identify\n    // that only an id needs to be fetched.\n    // @todo maybe move this into transformFields() instead of here\n    fields = fields.filter(field => {\n      const fieldTypeName = findNamedTypeName(field.type)\n      return fieldTypeName !== grandParentTypeName\n    })\n  }\n\n  const typeIncarnationCount = countIncarnations({\n    typeName,\n    ancestorTypeNames,\n  })\n\n  if (typeIncarnationCount >= circularQueryLimit) {\n    return null\n  }\n\n  parentAncestorTypeNames.push(typeName)\n\n  const recursivelyTransformedFields = transformFields({\n    fields,\n    parentType,\n    mainType,\n    fragments,\n    parentField,\n    ancestorTypeNames: parentAncestorTypeNames,\n    depth,\n    fieldBlacklist,\n    fieldAliases,\n    typeMap,\n    gatsbyNodesInfo,\n    queryDepth,\n    circularQueryLimit,\n    pluginOptions,\n    buildingFragment,\n  })\n\n  if (!recursivelyTransformedFields.length) {\n    return null\n  }\n\n  return recursivelyTransformedFields\n}\n\nexport default recursivelyTransformFields\n"],"mappings":"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"}