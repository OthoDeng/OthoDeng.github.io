{"version":3,"file":"build-query-on-field-name.js","names":["buildReusableFragments","fragments","Object","values","map","name","type","fields","inlineFragments","buildSelectionSet","buildInlineFragments","join","generateReusableFragments","selectionSet","fragmentsValues","length","builtFragments","regenerateFragments","forEach","includes","buildNodesQueryOnFieldName","fieldName","builtSelectionSet","queryVariables","fieldVariables","buildQuery","queryName","variables","buildVariables","buildInlineFragment","inlineFragment","transformedInlineFragments","remoteSchema","typeMap","store","getState","buildFieldSelectionSet","field","fieldType","internalType","fragment","find","builtInlineFragments","fullFieldType","get","findNamedTypeName","inlineFragmentsSelectionSet","filter","Boolean","buildNodeQueryOnFieldName","fieldInputArguments"],"sources":["../../../../src/steps/ingest-remote-schema/build-queries-from-introspection/build-query-on-field-name.js"],"sourcesContent":["import store from \"~/store\"\nimport { findNamedTypeName } from \"~/steps/create-schema-customization/helpers\"\n\nconst buildReusableFragments = ({ fragments }) =>\n  Object.values(fragments)\n    .map(\n      ({\n        name,\n        type,\n        fields,\n        inlineFragments,\n      }) => `fragment ${name} on ${type} {\n      ${buildSelectionSet(fields)}\n      ${buildInlineFragments(inlineFragments)}\n    }`\n    )\n    .join(` `)\n\n/**\n * Takes in a fragments object (built up during the buildSelectionSet function)\n * transforms that object into an actual fragment,\n * then checks for unused fragments and potential regenerates again\n * with the unused fragments removed\n */\nexport const generateReusableFragments = ({ fragments, selectionSet }) => {\n  const fragmentsValues = Object.values(fragments)\n\n  if (!fragmentsValues.length) {\n    return ``\n  }\n\n  let builtFragments = buildReusableFragments({ fragments })\n\n  if (fragments) {\n    let regenerateFragments = false\n\n    fragmentsValues.forEach(({ name, type }) => {\n      // if our query didn't use the fragment due to the query depth AND the fragment isn't used in another fragment, delete it\n      // @todo these fragments shouldn't be generated if they wont be used.\n      // if we fix this todo, we can use the buildReusableFragments function directly\n      // instead of running it twice to remove unused fragments\n      if (\n        !selectionSet.includes(`...${name}`) &&\n        !builtFragments.includes(`...${name}`)\n      ) {\n        delete fragments[type]\n        regenerateFragments = true\n      }\n    })\n\n    if (regenerateFragments) {\n      builtFragments = buildReusableFragments({ fragments })\n    }\n  }\n\n  return builtFragments\n}\n\nexport const buildNodesQueryOnFieldName = ({\n  fieldName,\n  builtSelectionSet,\n  builtFragments = ``,\n  queryVariables = ``,\n  fieldVariables = ``,\n}) =>\n  buildQuery({\n    queryName: `NODE_LIST_QUERY`,\n    variables: `$first: Int!, $after: String, ${queryVariables}`,\n    fieldName,\n    fieldVariables: `first: $first, after: $after, ${fieldVariables}`,\n    builtSelectionSet: `\n        nodes {\n          ${builtSelectionSet}\n        }\n        pageInfo {\n          hasNextPage\n          endCursor\n        }\n      `,\n    builtFragments,\n  })\n\nconst buildVariables = variables =>\n  variables && typeof variables === `string` ? `(${variables})` : ``\n\nconst buildInlineFragment = ({ name, fields, fragments }) => `\n  ... on ${name} {\n    ${buildSelectionSet(fields, { fragments })}\n  }\n`\n\nconst buildInlineFragments = (inlineFragments, { fragments = {} } = {}) =>\n  inlineFragments\n    ? `\n      __typename\n      ${inlineFragments\n        .map(inlineFragment =>\n          buildInlineFragment({ ...inlineFragment, fragments })\n        )\n        .join(` `)}\n    `\n    : ``\n\nexport const buildSelectionSet = (\n  fields,\n  { fragments = {}, transformedInlineFragments = [] } = {}\n) => {\n  if (!fields || !fields.length) {\n    return ``\n  }\n\n  const {\n    remoteSchema: { typeMap },\n  } = store.getState()\n\n  const buildFieldSelectionSet = field => {\n    if (typeof field === `string`) {\n      return field\n    }\n\n    let {\n      fieldName,\n      variables,\n      fields,\n      inlineFragments,\n      fieldType,\n      internalType,\n      builtSelectionSet,\n    } = field\n\n    if (internalType === `Fragment`) {\n      return `...${field.fragment.name}`\n    }\n\n    if (\n      (!variables || variables === ``) &&\n      fields?.find(field => field.fieldName === `nodes`)\n    ) {\n      // @todo instead of checking for a nodes field, include the field type here\n      // and check for input args instead. Maybe some kind of input args API or something would be helpful\n      variables = `first: 100`\n    }\n\n    const selectionSet =\n      builtSelectionSet ||\n      buildSelectionSet(fields, {\n        fragments,\n      })\n\n    const builtInlineFragments = buildInlineFragments(inlineFragments, {\n      fragments,\n    })\n\n    if (fieldName && (builtInlineFragments !== `` || selectionSet !== ``)) {\n      return `\n        ${fieldName} ${buildVariables(variables)} {\n          ${selectionSet}\n          ${builtInlineFragments}\n        }\n      `\n    } else if (fieldName) {\n      const fullFieldType = typeMap.get(findNamedTypeName(fieldType))\n\n      // if this field has subfields but we didn't build a selection set for it\n      // we shouldn't fetch this field. This can happen when we have self referencing types that are limited by the schema.circularQueryLimit plugin option.\n      // @todo the above should be fixed in recursively-transform-fields.js instead of here. recursion is hard :p\n      if (fullFieldType.fields) {\n        return null\n      }\n\n      return fieldName\n    }\n\n    return null\n  }\n\n  let inlineFragmentsSelectionSet = ``\n\n  if (transformedInlineFragments?.length) {\n    inlineFragmentsSelectionSet = transformedInlineFragments.map(\n      inlineFragment => `... on ${inlineFragment.name} {\n        ${inlineFragment.fields.map(buildFieldSelectionSet).filter(Boolean)\n          .join(`\n        `)}\n      }`\n    )\n  }\n\n  const selectionSet = fields.map(buildFieldSelectionSet).filter(Boolean).join(`\n    `)\n\n  return `${inlineFragmentsSelectionSet} ${selectionSet}`\n}\n\nconst buildQuery = ({\n  queryName,\n  fieldName,\n  fieldVariables,\n  variables,\n  builtSelectionSet,\n  builtFragments = ``,\n}) => `\n  query ${queryName} ${buildVariables(variables)} {\n    ${fieldName} ${buildVariables(fieldVariables)} {\n      ${builtSelectionSet}\n    }\n  }\n\n  ${builtFragments}\n`\n\nexport const buildNodeQueryOnFieldName = ({\n  fieldName,\n  builtFragments,\n  builtSelectionSet,\n  variables = `$id: ID!`,\n  fieldInputArguments = `id: $id`,\n  queryName = `SINGLE_CONTENT_QUERY`,\n}) =>\n  buildQuery({\n    queryName,\n    variables,\n    fieldName,\n    fieldVariables: fieldInputArguments,\n    builtFragments,\n    builtSelectionSet,\n  })\n"],"mappings":"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"}