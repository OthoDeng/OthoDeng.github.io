{"version":3,"file":"generate-queries-from-ingestable-types.js","names":["recursivelyAliasFragments","field","inlineFragments","map","fragment","fields","fragmentField","updatedFragmentField","forEach","possiblyConflictingFragment","name","possiblyConflictingField","fieldNamesMatch","fieldName","fieldTypeKindsDontMatch","fieldType","kind","fieldTypeNamesDontMatch","autoAliasedFieldName","aliasConflictingFieldFields","aliasConflictingFields","transformedFields","aliasConflictingFragmentFields","fragments","fragmentKey","Object","entries","aliasedFragment","generateNodeQueriesFromIngestibleFields","remoteSchema","gatsbyApi","helpers","reporter","pluginOptions","debug","graphql","copyNodeSourcingQueryAndExit","store","getState","fieldBlacklist","nodeListFilter","typeMap","ingestibles","nodeListRootFields","rootFields","get","nodeQueries","type","includes","fieldFields","nodesField","find","nodesType","findNamedTypeName","panic","formatLogMessage","possibleTypes","settings","getTypeSettingsByType","exclude","nodeListQueries","singleNodeRootFieldInfo","warn","singleFieldName","recursivelyTransformFields","parentType","mainType","push","transformedInlineFragments","transformInlineFragments","buildGatsbyNodeFields","inlineFragment","aliasedTransformedFields","selectionSet","buildSelectionSet","fieldPath","builtFragments","generateReusableFragments","nodeQuery","buildNodeQueryOnFieldName","builtSelectionSet","previewQuery","fieldInputArguments","queryName","fieldVariables","where","queries","buildNodesQueryOnFieldName","length","nodeListQuery","process","env","NODE_ENV","log","clipboardy","write","prettier","format","parser","exit","e","error","typeInfo","singularName","pluralName","nodesTypeName"],"sources":["../../../../src/steps/ingest-remote-schema/build-queries-from-introspection/generate-queries-from-ingestable-types.js"],"sourcesContent":["import recursivelyTransformFields, {\n  transformInlineFragments,\n} from \"./recursively-transform-fields\"\n\nimport {\n  buildNodesQueryOnFieldName,\n  buildNodeQueryOnFieldName,\n  buildSelectionSet,\n  generateReusableFragments,\n} from \"./build-query-on-field-name\"\n\nimport clipboardy from \"clipboardy\"\n\nimport store from \"~/store\"\nimport { getTypeSettingsByType } from \"~/steps/create-schema-customization/helpers\"\nimport prettier from \"prettier\"\nimport { formatLogMessage } from \"~/utils/format-log-message\"\nimport { findNamedTypeName } from \"../../create-schema-customization/helpers\"\n\nconst recursivelyAliasFragments = field =>\n  field.inlineFragments.map(fragment => {\n    // for each of this inlineFragments fields\n    fragment.fields = fragment.fields.map(fragmentField => {\n      if (typeof fragmentField === `string`) {\n        return fragmentField\n      }\n\n      // compare it against each field of each other fragment\n      let updatedFragmentField = fragmentField\n\n      field.inlineFragments.forEach(possiblyConflictingFragment => {\n        // don't compare this fragment against itself\n        if (possiblyConflictingFragment.name === fragment.name) {\n          return\n        }\n\n        possiblyConflictingFragment.fields.forEach(possiblyConflictingField => {\n          const fieldNamesMatch =\n            fragmentField.fieldName === possiblyConflictingField.fieldName\n\n          const fieldTypeKindsDontMatch =\n            possiblyConflictingField?.fieldType?.kind !==\n            fragmentField?.fieldType?.kind\n\n          const fieldTypeNamesDontMatch =\n            possiblyConflictingField?.fieldType?.name !==\n            fragmentField?.fieldType?.name\n\n          // if the fields have the same name but a different type kind\n          // alias them\n          if (\n            fieldNamesMatch &&\n            (fieldTypeKindsDontMatch || fieldTypeNamesDontMatch)\n          ) {\n            const autoAliasedFieldName = `${fragmentField.fieldName}__typename_${fragmentField.fieldType.name}: ${fragmentField.fieldName}`\n\n            updatedFragmentField = {\n              ...fragmentField,\n              fieldName: autoAliasedFieldName,\n            }\n\n            return\n          }\n        })\n      })\n      // if the fields have the same name but a different type AND the field has sub fields, compare those sub fields against any fragment fields subfields where the field name matches\n      // if any subfields have conflicting types, alias them\n\n      if (updatedFragmentField.inlineFragments) {\n        updatedFragmentField.inlineFragments =\n          recursivelyAliasFragments(updatedFragmentField)\n      }\n\n      return updatedFragmentField\n    })\n\n    return fragment\n  })\n\nconst aliasConflictingFieldFields = field => {\n  // we only have conflicting fields in inlineFragments\n  // if there are no inlineFragments, do nothing\n  if (!field.inlineFragments) {\n    return field\n  }\n\n  field.inlineFragments = recursivelyAliasFragments(field)\n\n  if (field.fields) {\n    field.fields = aliasConflictingFields({\n      transformedFields: field.fields,\n    })\n  }\n\n  return field\n}\n\nconst aliasConflictingFields = ({ transformedFields }) =>\n  transformedFields.map(aliasConflictingFieldFields)\n\nconst aliasConflictingFragmentFields = ({ fragments }) => {\n  for (const [fragmentKey, fragment] of Object.entries(fragments)) {\n    const aliasedFragment = aliasConflictingFieldFields(fragment)\n\n    fragments[fragmentKey] = aliasedFragment\n  }\n}\n\n/**\n * generateNodeQueriesFromIngestibleFields\n *\n * Takes in data from an introspection query and\n * processes it to build GraphQL query strings/info\n *\n * @param {object} introspectionData\n * @returns {Object} GraphQL query info including gql query strings\n */\nconst generateNodeQueriesFromIngestibleFields = async () => {\n  const {\n    remoteSchema,\n    gatsbyApi: {\n      helpers: { reporter },\n      pluginOptions: {\n        debug: {\n          graphql: { copyNodeSourcingQueryAndExit },\n        },\n      },\n    },\n  } = store.getState()\n\n  const {\n    fieldBlacklist,\n    nodeListFilter,\n    typeMap,\n    ingestibles: { nodeListRootFields },\n  } = remoteSchema\n\n  const rootFields = typeMap.get(`RootQuery`).fields\n\n  const nodeQueries = {}\n\n  for (const { type, name } of nodeListRootFields) {\n    if (fieldBlacklist.includes(name)) {\n      continue\n    }\n\n    // nested fields\n    const fieldFields = typeMap.get(type.name).fields\n\n    // a nested field containing a list of nodes\n    const nodesField = fieldFields.find(nodeListFilter)\n\n    // the type of this query\n    const nodesType = typeMap.get(findNamedTypeName(nodesField.type))\n\n    if (!nodesType) {\n      reporter.panic(\n        formatLogMessage(\n          `Couldn't infer node type in the remote schema from the ${name} root field.`\n        )\n      )\n    }\n\n    const { fields, possibleTypes } = nodesType\n\n    const settings = getTypeSettingsByType(nodesType)\n\n    if (settings.exclude) {\n      continue\n    }\n\n    let nodeListQueries = []\n\n    const singleNodeRootFieldInfo = rootFields.find(\n      field => field.type.name === nodesType.name\n    )\n\n    if (!singleNodeRootFieldInfo) {\n      // @todo handle cases where there is a nodelist field but no individual field. we can't do data updates or preview on this type.\n      reporter.warn(\n        formatLogMessage(\n          `Unable to find a single Node query for ${nodesType.name}\\n\\tThis type will not be available in Gatsby.\\n`\n        )\n      )\n      continue\n    }\n\n    const fragments = {}\n\n    const singleFieldName = singleNodeRootFieldInfo?.name\n\n    const transformedFields = recursivelyTransformFields({\n      fields,\n      fragments,\n      parentType: type,\n      mainType: type,\n    })\n\n    // we need this for node interface types on the WPGQL side\n    transformedFields.push(`__typename`)\n\n    let transformedInlineFragments\n\n    if (possibleTypes) {\n      transformedInlineFragments = transformInlineFragments({\n        possibleTypes,\n        fragments,\n        parentType: nodesType,\n        mainType: nodesType,\n        debug: true,\n        // normally we only want the id for gatsby node fields\n        // but in this case we're at the top level and need to query\n        // these fields\n        buildGatsbyNodeFields: true,\n      })\n\n      // alias conflicting inline fragment fields\n      transformedInlineFragments = transformedInlineFragments.map(\n        ({ fields, ...inlineFragment }) => {\n          return {\n            ...inlineFragment,\n            fields: aliasConflictingFields({\n              transformedFields: fields,\n            }),\n          }\n        }\n      )\n    }\n\n    // mutates the fragments..\n    aliasConflictingFragmentFields({ fragments })\n\n    const aliasedTransformedFields = aliasConflictingFields({\n      transformedFields,\n      parentType: type,\n    })\n\n    const selectionSet = buildSelectionSet(aliasedTransformedFields, {\n      fieldPath: name,\n      fragments,\n      transformedInlineFragments,\n    })\n\n    const builtFragments = generateReusableFragments({\n      fragments,\n      selectionSet,\n    })\n\n    const nodeQuery = buildNodeQueryOnFieldName({\n      fields: transformedFields,\n      fieldName: singleFieldName,\n      settings,\n      builtFragments,\n      builtSelectionSet: selectionSet,\n    })\n\n    const previewQuery = buildNodeQueryOnFieldName({\n      fields: transformedFields,\n      fieldName: singleFieldName,\n      fieldInputArguments: `id: $id, idType: ID, asPreview: true`,\n      queryName: `PREVIEW_QUERY`,\n      settings,\n      builtFragments,\n      builtSelectionSet: selectionSet,\n    })\n\n    const fieldVariables = settings.where ? `where: { ${settings.where} }` : ``\n\n    if (\n      settings.nodeListQueries &&\n      typeof settings.nodeListQueries === `function`\n    ) {\n      const queries = settings.nodeListQueries({\n        name,\n        fields,\n        selectionSet,\n        builtFragments,\n        singleFieldName,\n        singleNodeRootFieldInfo,\n        settings,\n        store,\n        fieldVariables,\n        remoteSchema,\n        transformedFields,\n        helpers: {\n          recursivelyTransformFields,\n          buildNodesQueryOnFieldName,\n        },\n      })\n\n      if (queries && queries.length) {\n        nodeListQueries = queries\n      }\n    }\n\n    if (!nodeListQueries || !nodeListQueries.length) {\n      const nodeListQuery = buildNodesQueryOnFieldName({\n        fields: transformedFields,\n        fieldName: name,\n        fieldVariables,\n        settings,\n        builtFragments,\n        builtSelectionSet: selectionSet,\n      })\n\n      nodeListQueries = [nodeListQuery]\n    }\n\n    if (\n      process.env.NODE_ENV === `development` &&\n      nodesType.name === copyNodeSourcingQueryAndExit\n    ) {\n      try {\n        reporter.log(``)\n        reporter.warn(\n          formatLogMessage(\n            `Query debug mode. Writing node list query for the ${nodesType.name} node type to the system clipboard and exiting\\n\\n`\n          )\n        )\n        await clipboardy.write(\n          prettier.format(nodeListQueries[0], { parser: `graphql` })\n        )\n        process.exit()\n      } catch (e) {\n        reporter.log(``)\n        reporter.error(e)\n        reporter.log(``)\n        reporter.warn(\n          formatLogMessage(\n            `Query debug mode failed. There was a failed attempt to copy the query for the ${nodesType.name} node type to your clipboard.\\n\\n`\n          )\n        )\n        reporter.error(e)\n      }\n    }\n\n    // build a query info object containing gql query strings for fetching\n    // node lists or single nodes, as well as type info and plugin\n    // settings for this type\n    nodeQueries[name] = {\n      typeInfo: {\n        singularName: singleFieldName,\n        pluralName: name,\n        nodesTypeName: nodesType.name,\n      },\n      nodeListQueries,\n      nodeQuery,\n      previewQuery,\n      selectionSet,\n      builtFragments,\n      settings,\n    }\n  }\n\n  return nodeQueries\n}\n\nexport default generateNodeQueriesFromIngestibleFields\n"],"mappings":"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"}