{"version":3,"file":"identify-and-store-ingestable-types.js","names":["identifyAndStoreIngestableFieldsAndTypes","nodeListFilter","field","name","state","store","getState","introspectionData","fieldBlacklist","typeMap","remoteSchema","pluginOptions","gatsbyApi","cachedFetchedTypes","getPersistentCache","key","restoredFetchedTypesMap","Map","dispatch","setState","fetchedTypes","nodeInterfaceTypes","nodeListRootFields","nonNodeRootFields","nodeInterfacePossibleTypeNames","type","Object","entries","forEach","typeName","typeSettings","lazyNodes","__all","typeIsExcluded","lazyType","get","addFetchedType","nodeInterface","push","rootFields","fields","fieldHasNonNullArgs","args","some","arg","kind","nodeField","find","findNamedType","nodeListField","findNamedTypeName","nodeListFieldType","innerField","nodeInterfaceType","possibleTypes","includes","takesIDinput","RootQuery","excludeFieldNames","excludedFieldName","typeIsABuiltInScalar","interfaces","__schema","types","filter","interfaceType","typesThatImplementInterface","getTypesThatImplementInterfaceType","shouldSkipInterfaceType","transformFields","parentType","parentInterfacesImplementingTypes","peek","interfaceField","nodeListFieldNames","map","nodeListTypeNames","connectionType","nodesField","gatsbyNodesInfo","fieldNames","typeNames","ingestibles"],"sources":["../../../src/steps/ingest-remote-schema/identify-and-store-ingestable-types.js"],"sourcesContent":["import store from \"~/store\"\nimport { typeIsExcluded } from \"~/steps/ingest-remote-schema/is-excluded\"\nimport { typeIsABuiltInScalar } from \"../create-schema-customization/helpers\"\nimport {\n  findNamedTypeName,\n  getTypesThatImplementInterfaceType,\n  findNamedType,\n} from \"~/steps/create-schema-customization/helpers\"\nimport { transformFields } from \"../create-schema-customization/transform-fields\"\nimport { getPersistentCache } from \"~/utils/cache\"\n\nconst identifyAndStoreIngestableFieldsAndTypes = async () => {\n  const nodeListFilter = field => field.name === `nodes`\n\n  const state = store.getState()\n  const { introspectionData, fieldBlacklist, typeMap } = state.remoteSchema\n  const { pluginOptions } = state.gatsbyApi\n\n  const cachedFetchedTypes = await getPersistentCache({\n    key: `previously-fetched-types`,\n  })\n\n  if (cachedFetchedTypes) {\n    const restoredFetchedTypesMap = new Map(cachedFetchedTypes)\n\n    store.dispatch.remoteSchema.setState({\n      fetchedTypes: restoredFetchedTypesMap,\n    })\n  }\n\n  const nodeInterfaceTypes = []\n  const nodeListRootFields = []\n  const nonNodeRootFields = []\n  const nodeInterfacePossibleTypeNames = []\n\n  if (pluginOptions.type) {\n    Object.entries(pluginOptions.type).forEach(([typeName, typeSettings]) => {\n      // our lazy types won't initially be fetched,\n      // so we need to mark them as fetched here\n      if (\n        (typeSettings.lazyNodes || pluginOptions.type?.__all?.lazyNodes) &&\n        !typeIsExcluded({ pluginOptions, typeName })\n      ) {\n        const lazyType = typeMap.get(typeName)\n        store.dispatch.remoteSchema.addFetchedType(lazyType)\n      }\n\n      if (typeSettings.nodeInterface) {\n        nodeInterfaceTypes.push(typeName)\n      }\n    })\n  }\n\n  const rootFields = typeMap.get(`RootQuery`).fields\n\n  for (const field of rootFields) {\n    const fieldHasNonNullArgs = field.args.some(\n      arg => arg.type.kind === `NON_NULL`\n    )\n\n    if (fieldHasNonNullArgs) {\n      // we can't know what those args should be, so skip this field\n      continue\n    }\n\n    if (typeIsExcluded({ pluginOptions, typeName: field.type.name })) {\n      continue\n    }\n\n    if (field.type.kind === `OBJECT`) {\n      const type = typeMap.get(field.type.name)\n\n      const nodeField = type?.fields?.find(nodeListFilter)\n\n      if (nodeField && findNamedType(nodeField.type).kind === `INTERFACE`) {\n        const nodeListField = type.fields.find(nodeListFilter)\n\n        if (nodeListField) {\n          nodeInterfaceTypes.push(findNamedTypeName(nodeListField.type))\n\n          store.dispatch.remoteSchema.addFetchedType(nodeListField.type)\n\n          const nodeListFieldType = typeMap.get(\n            findNamedTypeName(nodeListField.type)\n          )\n\n          for (const innerField of nodeListFieldType.fields) {\n            store.dispatch.remoteSchema.addFetchedType(innerField.type)\n          }\n\n          if (\n            // if we haven't marked this as a nodeInterface type then push this to root fields to fetch it\n            // nodeInterface is different than a node which is an interface type.\n            // In Gatsby nodeInterface means the node data is pulled from a different type. On the WP side we can also have nodes that are of an interface type, but we only pull them from a single root field\n            // the problem is that if we don't mark them as a node list root field\n            // we don't know to identify them later as being a node type that will have been fetched and we also wont try to fetch this type during node sourcing.\n            !pluginOptions?.type?.[findNamedTypeName(nodeListField.type)]\n              ?.nodeInterface\n          ) {\n            const nodeInterfaceType = typeMap.get(\n              findNamedTypeName(nodeListField.type)\n            )\n\n            // we need to mark all the possible types as being fetched\n            // and also need to record the possible type as a node type\n            for (const type of nodeInterfaceType?.possibleTypes || []) {\n              nodeInterfacePossibleTypeNames.push(type.name)\n              store.dispatch.remoteSchema.addFetchedType(type)\n            }\n\n            nodeListRootFields.push(field)\n          }\n\n          continue\n        }\n      } else if (nodeField) {\n        if (fieldBlacklist.includes(field.name)) {\n          continue\n        }\n\n        store.dispatch.remoteSchema.addFetchedType(nodeField.type)\n\n        nodeListRootFields.push(field)\n        continue\n      }\n    }\n\n    if (fieldBlacklist.includes(field.name)) {\n      continue\n    }\n\n    const takesIDinput = field?.args?.find(arg => arg.type.name === `ID`)\n\n    // if a non-node root field takes an id input, we 99% likely can't use it.\n    // so don't fetch it and don't add it to the schema.\n    if (takesIDinput) {\n      continue\n    }\n\n    if (\n      // if this type is excluded on the RootQuery, skip it\n      pluginOptions.type.RootQuery?.excludeFieldNames?.find(\n        excludedFieldName => excludedFieldName === field.name\n      )\n    ) {\n      continue\n    }\n\n    // we don't need to mark types as fetched if they're supported SCALAR types\n    if (!typeIsABuiltInScalar(field.type)) {\n      store.dispatch.remoteSchema.addFetchedType(field.type)\n    }\n\n    nonNodeRootFields.push(field)\n  }\n\n  const interfaces = introspectionData.__schema.types.filter(\n    type => type.kind === `INTERFACE`\n  )\n\n  for (const interfaceType of interfaces) {\n    if (typeIsExcluded({ pluginOptions, typeName: interfaceType.name })) {\n      continue\n    }\n\n    if (!interfaceType.fields) {\n      continue\n    }\n\n    const typesThatImplementInterface =\n      getTypesThatImplementInterfaceType(interfaceType)\n\n    const shouldSkipInterfaceType = !transformFields({\n      fields: interfaceType.fields,\n      parentType: interfaceType,\n      parentInterfacesImplementingTypes: typesThatImplementInterface,\n      peek: true,\n    })\n\n    if (shouldSkipInterfaceType && interfaceType.name !== `Node`) {\n      continue\n    }\n\n    store.dispatch.remoteSchema.addFetchedType(interfaceType)\n\n    if (interfaceType.fields) {\n      for (const interfaceField of interfaceType.fields) {\n        if (interfaceField.type) {\n          store.dispatch.remoteSchema.addFetchedType(interfaceField.type)\n        }\n      }\n    }\n  }\n\n  const nodeListFieldNames = nodeListRootFields.map(field => field.name)\n\n  const nodeListTypeNames = [\n    ...nodeInterfacePossibleTypeNames,\n    ...nodeListRootFields.map(field => {\n      const connectionType = typeMap.get(field.type.name)\n\n      const nodesField = connectionType.fields.find(nodeListFilter)\n      return findNamedType(nodesField.type).name\n    }),\n  ]\n\n  const gatsbyNodesInfo = {\n    fieldNames: nodeListFieldNames,\n    typeNames: nodeListTypeNames,\n  }\n\n  store.dispatch.remoteSchema.setState({\n    gatsbyNodesInfo,\n    ingestibles: {\n      nodeListRootFields,\n      nonNodeRootFields,\n      nodeInterfaceTypes,\n    },\n  })\n}\n\nexport { identifyAndStoreIngestableFieldsAndTypes }\n"],"mappings":"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"}