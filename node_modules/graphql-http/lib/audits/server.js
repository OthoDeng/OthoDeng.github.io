"use strict";
/**
 *
 * audit/server
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.auditServer = exports.serverAudits = void 0;
const utils_1 = require("./utils");
/**
 * List of server audits required to check GraphQL over HTTP spec conformance.
 *
 * @category Audits
 */
function serverAudits(opts) {
    const fetchFn = (opts.fetchFn || fetch);
    return [
        // Media Types
        (0, utils_1.audit)(
        // TODO: convert to MUST after watershed
        'SHOULD accept application/graphql-response+json and match the content-type', async () => {
            const res = await fetchFn(await getUrl(opts.url), {
                method: 'POST',
                headers: {
                    'content-type': 'application/json',
                    accept: 'application/graphql-response+json',
                },
                body: JSON.stringify({ query: '{ __typename }' }),
            });
            (0, utils_1.assert)('Status code', res.status).toBe(200);
            (0, utils_1.assert)('Content-Type header', res.headers.get('content-type')).toContain('application/graphql-response+json');
        }),
        (0, utils_1.audit)('MUST accept application/json and match the content-type', async () => {
            const res = await fetchFn(await getUrl(opts.url), {
                method: 'POST',
                headers: {
                    'content-type': 'application/json',
                    accept: 'application/json',
                },
                body: JSON.stringify({ query: '{ __typename }' }),
            });
            (0, utils_1.assert)('Status code', res.status).toBe(200);
            (0, utils_1.assert)('Content-Type header', res.headers.get('content-type')).toContain('application/json');
        }),
        (0, utils_1.audit)('SHOULD accept */* and use application/json for the content-type', async () => {
            const res = await fetchFn(await getUrl(opts.url), {
                method: 'POST',
                headers: {
                    'content-type': 'application/json',
                    accept: '*/*',
                },
                body: JSON.stringify({ query: '{ __typename }' }),
            });
            (0, utils_1.assert)('Status code', res.status).toBe(200);
            (0, utils_1.assert)('Content-Type header', res.headers.get('content-type')).toContain('application/json');
        }),
        (0, utils_1.audit)('SHOULD assume application/json content-type when accept is missing', async () => {
            const url = new URL(await getUrl(opts.url));
            url.searchParams.set('query', '{ __typename }');
            const res = await fetchFn(url.toString());
            (0, utils_1.assert)('Status code', res.status).toBe(200);
            (0, utils_1.assert)('Content-Type header', res.headers.get('content-type')).toContain('application/json');
        }),
        (0, utils_1.audit)('MUST use utf-8 encoding when responding', async () => {
            const res = await fetchFn(await getUrl(opts.url), {
                method: 'POST',
                headers: {
                    'content-type': 'application/json',
                },
                body: JSON.stringify({ query: '{ __typename }' }),
            });
            (0, utils_1.assert)('Status code', res.status).toBe(200);
            // has charset set to utf-8
            try {
                (0, utils_1.assert)('Content-Type header', res.headers.get('content-type')).toContain('charset=utf-8');
                return;
            }
            catch (_a) {
                // noop, continue
            }
            // has no charset specified
            (0, utils_1.assert)('Content-Type header', res.headers.get('content-type')).notToContain('charset');
            // and the content is utf-8 encoded
            try {
                const decoder = new TextDecoder('utf-8');
                const decoded = decoder.decode(await res.arrayBuffer());
                (0, utils_1.assert)('UTF-8 decoded body', decoded).toBe('{"data":{"__typename":"Query"}}');
            }
            catch (_b) {
                throw 'Body is not UTF-8 encoded';
            }
        }),
        (0, utils_1.audit)('MUST accept utf-8 encoding', async () => {
            const res = await fetchFn(await getUrl(opts.url), {
                method: 'POST',
                headers: {
                    'content-type': 'application/json; charset=utf-8',
                },
                body: JSON.stringify({ query: '{ __typename }' }),
            });
            (0, utils_1.assert)('Status code', res.status).toBe(200);
            (0, utils_1.assert)('Content-Type header', res.headers.get('content-type')).toContain('utf-8');
        }),
        (0, utils_1.audit)('MUST assume utf-8 if encoding is unspecified', async () => {
            const res = await fetchFn(await getUrl(opts.url), {
                method: 'POST',
                headers: {
                    'content-type': 'application/json',
                },
                body: JSON.stringify({ query: '{ __typename }' }),
            });
            (0, utils_1.assert)('Status code', res.status).toBe(200);
            (0, utils_1.assert)('Content-Type header', res.headers.get('content-type')).toContain('utf-8');
        }),
        // Request
        (0, utils_1.audit)('MUST accept POST requests', async () => {
            const res = await fetchFn(await getUrl(opts.url), {
                method: 'POST',
                headers: { 'content-type': 'application/json' },
                body: JSON.stringify({ query: '{ __typename }' }),
            });
            (0, utils_1.assert)('Status code', res.status).toBe(200);
        }),
        (0, utils_1.audit)('MAY accept application/x-www-form-urlencoded formatted GET requests', async () => {
            const url = new URL(await getUrl(opts.url));
            url.searchParams.set('query', '{ __typename }');
            const res = await fetchFn(url.toString());
            (0, utils_1.assert)('Status code', res.status).toBe(200);
        }),
        // Request GET
        // TODO: this is a MUST if the server supports GET requests
        (0, utils_1.audit)('MAY NOT allow executing mutations on GET requests', async () => {
            const url = new URL(await getUrl(opts.url));
            url.searchParams.set('query', 'mutation { __typename }');
            const res = await fetchFn(url.toString(), {
                headers: {
                    accept: 'application/graphql-response+json',
                },
            });
            (0, utils_1.assert)('Status code', res.status).toBeBetween(400, 499);
        }),
        // Request POST
        (0, utils_1.audit)('SHOULD respond with 4xx status code if content-type is not supplied on POST requests', async () => {
            const res = await fetchFn(await getUrl(opts.url), {
                method: 'POST',
            });
            (0, utils_1.assert)('Status code', res.status).toBeBetween(400, 499);
        }),
        (0, utils_1.audit)('MUST accept application/json POST requests', async () => {
            const res = await fetchFn(await getUrl(opts.url), {
                method: 'POST',
                headers: { 'content-type': 'application/json' },
                body: JSON.stringify({ query: '{ __typename }' }),
            });
            (0, utils_1.assert)('Status code', res.status).toBe(200);
        }),
        (0, utils_1.audit)('MUST require a request body on POST', async () => {
            var _a;
            const res = await fetchFn(await getUrl(opts.url), {
                method: 'POST',
                headers: { 'content-type': 'application/json' },
            });
            if ((_a = res.headers.get('content-type')) === null || _a === void 0 ? void 0 : _a.includes('application/json')) {
                (0, utils_1.assert)('Execution result', await (0, utils_1.assertBodyAsExecutionResult)(res)).toHaveProperty('errors');
            }
            else {
                (0, utils_1.assert)('Status code', res.status).toBe(400);
            }
        }),
        // Request Parameters
        (0, utils_1.audit)(
        // TODO: convert to MUST after watershed
        'SHOULD use 400 status code on missing {query} parameter when accepting application/graphql-response+json', async () => {
            const res = await fetchFn(await getUrl(opts.url), {
                method: 'POST',
                headers: {
                    'content-type': 'application/json',
                    accept: 'application/graphql-response+json',
                },
                body: JSON.stringify({ notquery: '{ __typename }' }),
            });
            (0, utils_1.assert)('Status code', res.status).toBe(400);
        }),
        (0, utils_1.audit)('SHOULD use 200 status code with errors field on missing {query} parameter when accepting application/json', async () => {
            const res = await fetchFn(await getUrl(opts.url), {
                method: 'POST',
                headers: {
                    'content-type': 'application/json',
                    accept: 'application/json',
                },
                body: JSON.stringify({ notquery: '{ __typename }' }),
            });
            (0, utils_1.assert)('Status code', res.status).toBe(200);
            (0, utils_1.assert)('Execution result', await (0, utils_1.assertBodyAsExecutionResult)(res)).toHaveProperty('errors');
        }),
        ...[{ obj: 'ect' }, 0, false, ['array']].map((invalid) => (0, utils_1.audit)(
        // TODO: convert to MUST after watershed
        `SHOULD use 400 status code on ${(0, utils_1.extendedTypeof)(invalid)} {query} parameter when accepting application/graphql-response+json`, async () => {
            const res = await fetchFn(await getUrl(opts.url), {
                method: 'POST',
                headers: {
                    'content-type': 'application/json',
                    accept: 'application/graphql-response+json',
                },
                body: JSON.stringify({
                    query: invalid,
                }),
            });
            (0, utils_1.assert)('Status code', res.status).toBe(400);
        })),
        ...[{ obj: 'ect' }, 0, false, ['array']].map((invalid) => (0, utils_1.audit)(`SHOULD use 200 status code with errors field on ${(0, utils_1.extendedTypeof)(invalid)} {query} parameter when accepting application/json`, async () => {
            const res = await fetchFn(await getUrl(opts.url), {
                method: 'POST',
                headers: {
                    'content-type': 'application/json',
                    accept: 'application/json',
                },
                body: JSON.stringify({
                    query: invalid,
                }),
            });
            (0, utils_1.assert)('Status code', res.status).toBe(200);
            (0, utils_1.assert)('Execution result', await (0, utils_1.assertBodyAsExecutionResult)(res)).toHaveProperty('errors');
        })),
        (0, utils_1.audit)(
        // TODO: convert to MUST after watershed
        'SHOULD allow string {query} parameter when accepting application/graphql-response+json', async () => {
            const res = await fetchFn(await getUrl(opts.url), {
                method: 'POST',
                headers: {
                    'content-type': 'application/json',
                    accept: 'application/graphql-response+json',
                },
                body: JSON.stringify({
                    query: '{ __typename }',
                }),
            });
            (0, utils_1.assert)('Status code', res.status).toBe(200);
        }),
        (0, utils_1.audit)('MUST allow string {query} parameter when accepting application/json', async () => {
            const res = await fetchFn(await getUrl(opts.url), {
                method: 'POST',
                headers: {
                    'content-type': 'application/json',
                    accept: 'application/json',
                },
                body: JSON.stringify({
                    query: '{ __typename }',
                }),
            });
            (0, utils_1.assert)('Status code', res.status).toBe(200);
            (0, utils_1.assert)('Execution result', await (0, utils_1.assertBodyAsExecutionResult)(res)).notToHaveProperty('errors');
        }),
        ...[{ obj: 'ect' }, 0, false, ['array']].map((invalid) => (0, utils_1.audit)(
        // TODO: convert to MUST after watershed
        `SHOULD use 400 status code on ${(0, utils_1.extendedTypeof)(invalid)} {operationName} parameter when accepting application/graphql-response+json`, async () => {
            const res = await fetchFn(await getUrl(opts.url), {
                method: 'POST',
                headers: {
                    'content-type': 'application/json',
                    accept: 'application/graphql-response+json',
                },
                body: JSON.stringify({
                    operationName: invalid,
                    query: '{ __typename }',
                }),
            });
            (0, utils_1.assert)('Status code', res.status).toBe(400);
        })),
        ...[{ obj: 'ect' }, 0, false, ['array']].map((invalid) => (0, utils_1.audit)(`SHOULD use 200 status code with errors field on ${(0, utils_1.extendedTypeof)(invalid)} {operationName} parameter when accepting application/json`, async () => {
            const res = await fetchFn(await getUrl(opts.url), {
                method: 'POST',
                headers: {
                    'content-type': 'application/json',
                    accept: 'application/json',
                },
                body: JSON.stringify({
                    operationName: invalid,
                    query: '{ __typename }',
                }),
            });
            (0, utils_1.assert)('Status code', res.status).toBe(200);
            (0, utils_1.assert)('Execution result', await (0, utils_1.assertBodyAsExecutionResult)(res)).toHaveProperty('errors');
        })),
        (0, utils_1.audit)(
        // TODO: convert to MUST after watershed
        'SHOULD allow string {operationName} parameter when accepting application/graphql-response+json', async () => {
            const res = await fetchFn(await getUrl(opts.url), {
                method: 'POST',
                headers: {
                    'content-type': 'application/json',
                    accept: 'application/graphql-response+json',
                },
                body: JSON.stringify({
                    operationName: 'Query',
                    query: 'query Query { __typename }',
                }),
            });
            (0, utils_1.assert)('Status code', res.status).toBe(200);
        }),
        (0, utils_1.audit)('MUST allow string {operationName} parameter when accepting application/json', async () => {
            const res = await fetchFn(await getUrl(opts.url), {
                method: 'POST',
                headers: {
                    'content-type': 'application/json',
                    accept: 'application/json',
                },
                body: JSON.stringify({
                    operationName: 'Query',
                    query: 'query Query { __typename }',
                }),
            });
            (0, utils_1.assert)('Status code', res.status).toBe(200);
            (0, utils_1.assert)('Execution result', await (0, utils_1.assertBodyAsExecutionResult)(res)).notToHaveProperty('errors');
        }),
        ...['variables', 'operationName', 'extensions'].flatMap((parameter) => [
            (0, utils_1.audit)(
            // TODO: convert to MUST after watershed
            `SHOULD allow null {${parameter}} parameter when accepting application/graphql-response+json`, async () => {
                const res = await fetchFn(await getUrl(opts.url), {
                    method: 'POST',
                    headers: {
                        'content-type': 'application/json',
                        accept: 'application/graphql-response+json',
                    },
                    body: JSON.stringify({
                        query: '{ __typename }',
                        [parameter]: null,
                    }),
                });
                (0, utils_1.assert)('Status code', res.status).toBe(200);
                (0, utils_1.assert)('Execution result', await (0, utils_1.assertBodyAsExecutionResult)(res)).notToHaveProperty('errors');
            }),
            (0, utils_1.audit)(`MUST allow null {${parameter}} parameter when accepting application/json`, async () => {
                const res = await fetchFn(await getUrl(opts.url), {
                    method: 'POST',
                    headers: {
                        'content-type': 'application/json',
                        accept: 'application/json',
                    },
                    body: JSON.stringify({
                        query: '{ __typename }',
                        [parameter]: null,
                    }),
                });
                (0, utils_1.assert)('Status code', res.status).toBe(200);
                (0, utils_1.assert)('Execution result', await (0, utils_1.assertBodyAsExecutionResult)(res)).notToHaveProperty('errors');
            }),
        ]),
        ...['string', 0, false, ['array']].map((invalid) => (0, utils_1.audit)(
        // TODO: convert to MUST after watershed
        `SHOULD use 400 status code on ${(0, utils_1.extendedTypeof)(invalid)} {variables} parameter when accepting application/graphql-response+json`, async () => {
            const res = await fetchFn(await getUrl(opts.url), {
                method: 'POST',
                headers: {
                    'content-type': 'application/json',
                    accept: 'application/graphql-response+json',
                },
                body: JSON.stringify({
                    query: '{ __typename }',
                    variables: invalid,
                }),
            });
            (0, utils_1.assert)('Status code', res.status).toBe(400);
        })),
        ...['string', 0, false, ['array']].map((invalid) => (0, utils_1.audit)(`SHOULD use 200 status code with errors field on ${(0, utils_1.extendedTypeof)(invalid)} {variables} parameter when accepting application/json`, async () => {
            const res = await fetchFn(await getUrl(opts.url), {
                method: 'POST',
                headers: {
                    'content-type': 'application/json',
                    accept: 'application/json',
                },
                body: JSON.stringify({
                    query: '{ __typename }',
                    variables: invalid,
                }),
            });
            (0, utils_1.assert)('Status code', res.status).toBe(200);
            (0, utils_1.assert)('Execution result', await (0, utils_1.assertBodyAsExecutionResult)(res)).toHaveProperty('errors');
        })),
        (0, utils_1.audit)(
        // TODO: convert to MUST after watershed
        'SHOULD allow map {variables} parameter when accepting application/graphql-response+json', async () => {
            const res = await fetchFn(await getUrl(opts.url), {
                method: 'POST',
                headers: {
                    'content-type': 'application/json',
                    accept: 'application/graphql-response+json',
                },
                body: JSON.stringify({
                    query: 'query Type($name: String!) { __type(name: $name) { name } }',
                    variables: { name: 'sometype' },
                }),
            });
            (0, utils_1.assert)('Status code', res.status).toBe(200);
        }),
        (0, utils_1.audit)('MUST allow map {variables} parameter when accepting application/json', async () => {
            const res = await fetchFn(await getUrl(opts.url), {
                method: 'POST',
                headers: {
                    'content-type': 'application/json',
                    accept: 'application/json',
                },
                body: JSON.stringify({
                    query: 'query Type($name: String!) { __type(name: $name) { name } }',
                    variables: { name: 'sometype' },
                }),
            });
            (0, utils_1.assert)('Status code', res.status).toBe(200);
            (0, utils_1.assert)('Execution result', await (0, utils_1.assertBodyAsExecutionResult)(res)).notToHaveProperty('errors');
        }),
        (0, utils_1.audit)('MAY allow URL-encoded JSON string {variables} parameter in GETs when accepting application/graphql-response+json', async () => {
            const url = new URL(await getUrl(opts.url));
            url.searchParams.set('query', 'query Type($name: String!) { __type(name: $name) { name } }');
            url.searchParams.set('variables', JSON.stringify({ name: 'sometype' }));
            const res = await fetchFn(url.toString(), {
                method: 'GET',
                headers: {
                    accept: 'application/graphql-response+json',
                },
            });
            (0, utils_1.assert)('Status code', res.status).toBe(200);
        }),
        (0, utils_1.audit)('MAY allow URL-encoded JSON string {variables} parameter in GETs when accepting application/json', async () => {
            const url = new URL(await getUrl(opts.url));
            url.searchParams.set('query', 'query Type($name: String!) { __type(name: $name) { name } }');
            url.searchParams.set('variables', JSON.stringify({ name: 'sometype' }));
            const res = await fetchFn(url.toString(), {
                method: 'GET',
                headers: {
                    accept: 'application/json',
                },
            });
            (0, utils_1.assert)('Status code', res.status).toBe(200);
            (0, utils_1.assert)('Execution result', await (0, utils_1.assertBodyAsExecutionResult)(res)).notToHaveProperty('errors');
        }),
        ...['string', 0, false, ['array']].map((invalid) => (0, utils_1.audit)(
        // TODO: convert to MUST after watershed
        `SHOULD use 400 status code on ${(0, utils_1.extendedTypeof)(invalid)} {extensions} parameter when accepting application/graphql-response+json`, async () => {
            const res = await fetchFn(await getUrl(opts.url), {
                method: 'POST',
                headers: {
                    'content-type': 'application/json',
                    accept: 'application/graphql-response+json',
                },
                body: JSON.stringify({
                    query: '{ __typename }',
                    extensions: invalid,
                }),
            });
            (0, utils_1.assert)('Status code', res.status).toBe(400);
        })),
        ...['string', 0, false, ['array']].map((invalid) => (0, utils_1.audit)(`SHOULD use 200 status code with errors field on ${(0, utils_1.extendedTypeof)(invalid)} {extensions} parameter when accepting application/json`, async () => {
            const res = await fetchFn(await getUrl(opts.url), {
                method: 'POST',
                headers: {
                    'content-type': 'application/json',
                    accept: 'application/json',
                },
                body: JSON.stringify({
                    query: '{ __typename }',
                    extensions: invalid,
                }),
            });
            (0, utils_1.assert)('Status code', res.status).toBe(200);
            (0, utils_1.assert)('Execution result', await (0, utils_1.assertBodyAsExecutionResult)(res)).toHaveProperty('errors');
        })),
        (0, utils_1.audit)(
        // TODO: convert to MUST after watershed
        'SHOULD allow map {extensions} parameter when accepting application/graphql-response+json', async () => {
            const res = await fetchFn(await getUrl(opts.url), {
                method: 'POST',
                headers: {
                    'content-type': 'application/json',
                    accept: 'application/graphql-response+json',
                },
                body: JSON.stringify({
                    query: '{ __typename }',
                    extensions: { some: 'value' },
                }),
            });
            (0, utils_1.assert)('Status code', res.status).toBe(200);
        }),
        (0, utils_1.audit)('MUST allow map {extensions} parameter when accepting application/json', async () => {
            const res = await fetchFn(await getUrl(opts.url), {
                method: 'POST',
                headers: {
                    'content-type': 'application/json',
                    accept: 'application/json',
                },
                body: JSON.stringify({
                    query: '{ __typename }',
                    extensions: { some: 'value' },
                }),
            });
            (0, utils_1.assert)('Status code', res.status).toBe(200);
            (0, utils_1.assert)('Execution result', await (0, utils_1.assertBodyAsExecutionResult)(res)).notToHaveProperty('errors');
        }),
        // TODO: audit('MUST accept a map for the {extensions} parameter'),
        // Response application/json
        (0, utils_1.audit)('SHOULD use 200 status code on JSON parsing failure when accepting application/json', async () => {
            const res = await fetchFn(await getUrl(opts.url), {
                method: 'POST',
                headers: {
                    'content-type': 'application/json',
                    accept: 'application/json',
                },
                body: '{ "not a JSON',
            });
            (0, utils_1.assert)('Status code', res.status).toBe(200);
        }),
        (0, utils_1.audit)('SHOULD use 200 status code if parameters are invalid when accepting application/json', async () => {
            const res = await fetchFn(await getUrl(opts.url), {
                method: 'POST',
                headers: {
                    'content-type': 'application/json',
                    accept: 'application/json',
                },
                body: JSON.stringify({
                    qeury: /* typo */ '{ __typename }',
                }),
            });
            (0, utils_1.assert)('Status code', res.status).toBe(200);
        }),
        (0, utils_1.audit)('SHOULD use 200 status code on document parsing failure when accepting application/json', async () => {
            const res = await fetchFn(await getUrl(opts.url), {
                method: 'POST',
                headers: {
                    'content-type': 'application/json',
                    accept: 'application/json',
                },
                body: JSON.stringify({ query: '{' }),
            });
            (0, utils_1.assert)('Status code', res.status).toBe(200);
        }),
        (0, utils_1.audit)('SHOULD use 200 status code on document validation failure when accepting application/json', async () => {
            const res = await fetchFn(await getUrl(opts.url), {
                method: 'POST',
                headers: {
                    'content-type': 'application/json',
                    accept: 'application/json',
                },
                body: JSON.stringify({
                    query: '{ 8f31403dfe404bccbb0e835f2629c6a7 }', // making sure the field doesnt exist
                }),
            });
            (0, utils_1.assert)('Status code', res.status).toBe(200);
        }),
        // Response application/graphql-response+json
        (0, utils_1.audit)(
        // TODO: convert to MUST after watershed
        'SHOULD use 4xx or 5xx status codes on JSON parsing failure when accepting application/graphql-response+json', async () => {
            const res = await fetchFn(await getUrl(opts.url), {
                method: 'POST',
                headers: {
                    'content-type': 'application/json',
                    accept: 'application/graphql-response+json',
                },
                body: '{ "not a JSON',
            });
            (0, utils_1.assert)('Status code', res.status).toBeBetween(400, 499);
        }),
        (0, utils_1.audit)('SHOULD use 400 status code on JSON parsing failure when accepting application/graphql-response+json', async () => {
            const res = await fetchFn(await getUrl(opts.url), {
                method: 'POST',
                headers: {
                    'content-type': 'application/json',
                    accept: 'application/graphql-response+json',
                },
                body: '{ "not a JSON',
            });
            (0, utils_1.assert)('Status code', res.status).toBe(400);
        }),
        (0, utils_1.audit)('SHOULD not contain the data entry on JSON parsing failure when accepting application/graphql-response+json', async () => {
            const res = await fetchFn(await getUrl(opts.url), {
                method: 'POST',
                headers: {
                    'content-type': 'application/json',
                    accept: 'application/graphql-response+json',
                },
                body: '{ "not a JSON',
            });
            (0, utils_1.assert)('Data entry', (await (0, utils_1.assertBodyAsExecutionResult)(res)).data).toBe(undefined);
        }),
        (0, utils_1.audit)(
        // TODO: convert to MUST after watershed
        'SHOULD use 4xx or 5xx status codes if parameters are invalid when accepting application/graphql-response+json', async () => {
            const res = await fetchFn(await getUrl(opts.url), {
                method: 'POST',
                headers: {
                    'content-type': 'application/json',
                    accept: 'application/graphql-response+json',
                },
                body: JSON.stringify({
                    qeury /* typo */: '{ __typename }',
                }),
            });
            (0, utils_1.assert)('Status code', res.status).toBeBetween(400, 599);
        }),
        (0, utils_1.audit)('SHOULD use 400 status code if parameters are invalid when accepting application/graphql-response+json', async () => {
            const res = await fetchFn(await getUrl(opts.url), {
                method: 'POST',
                headers: {
                    'content-type': 'application/json',
                    accept: 'application/graphql-response+json',
                },
                body: JSON.stringify({
                    qeury: /* typo */ '{ __typename }',
                }),
            });
            (0, utils_1.assert)('Status code', res.status).toBe(400);
        }),
        (0, utils_1.audit)('SHOULD not contain the data entry if parameters are invalid when accepting application/graphql-response+json', async () => {
            const res = await fetchFn(await getUrl(opts.url), {
                method: 'POST',
                headers: {
                    'content-type': 'application/json',
                    accept: 'application/graphql-response+json',
                },
                body: JSON.stringify({
                    qeury: /* typo */ '{ __typename }',
                }),
            });
            (0, utils_1.assert)('Data entry', (await (0, utils_1.assertBodyAsExecutionResult)(res)).data).toBe(undefined);
        }),
        (0, utils_1.audit)(
        // TODO: convert to MUST after watershed
        'SHOULD use 4xx or 5xx status codes on document parsing failure when accepting application/graphql-response+json', async () => {
            const res = await fetchFn(await getUrl(opts.url), {
                method: 'POST',
                headers: {
                    'content-type': 'application/json',
                    accept: 'application/graphql-response+json',
                },
                body: JSON.stringify({
                    query: '{',
                }),
            });
            (0, utils_1.assert)('Status code', res.status).toBeBetween(400, 599);
        }),
        (0, utils_1.audit)('SHOULD use 400 status code on document parsing failure when accepting application/graphql-response+json', async () => {
            const res = await fetchFn(await getUrl(opts.url), {
                method: 'POST',
                headers: {
                    'content-type': 'application/json',
                    accept: 'application/graphql-response+json',
                },
                body: JSON.stringify({
                    query: '{',
                }),
            });
            (0, utils_1.assert)('Status code', res.status).toBe(400);
        }),
        (0, utils_1.audit)('SHOULD not contain the data entry on document parsing failure when accepting application/graphql-response+json', async () => {
            const res = await fetchFn(await getUrl(opts.url), {
                method: 'POST',
                headers: {
                    'content-type': 'application/json',
                    accept: 'application/graphql-response+json',
                },
                body: JSON.stringify({
                    query: '{',
                }),
            });
            (0, utils_1.assert)('Data entry', (await (0, utils_1.assertBodyAsExecutionResult)(res)).data).toBe(undefined);
        }),
        (0, utils_1.audit)(
        // TODO: convert to MUST after watershed
        'SHOULD use 4xx or 5xx status codes on document validation failure when accepting application/graphql-response+json', async () => {
            const res = await fetchFn(await getUrl(opts.url), {
                method: 'POST',
                headers: {
                    'content-type': 'application/json',
                    accept: 'application/graphql-response+json',
                },
                body: JSON.stringify({
                    query: '{ 8f31403dfe404bccbb0e835f2629c6a7 }', // making sure the field doesnt exist
                }),
            });
            (0, utils_1.assert)('Status code', res.status).toBeBetween(400, 599);
        }),
        (0, utils_1.audit)('SHOULD use 400 status code on document validation failure when accepting application/graphql-response+json', async () => {
            const res = await fetchFn(await getUrl(opts.url), {
                method: 'POST',
                headers: {
                    'content-type': 'application/json',
                    accept: 'application/graphql-response+json',
                },
                body: JSON.stringify({
                    query: '{ 8f31403dfe404bccbb0e835f2629c6a7 }', // making sure the field doesnt exist
                }),
            });
            (0, utils_1.assert)('Status code', res.status).toBe(400);
        }),
        (0, utils_1.audit)('SHOULD not contain the data entry on document validation failure when accepting application/graphql-response+json', async () => {
            const res = await fetchFn(await getUrl(opts.url), {
                method: 'POST',
                headers: {
                    'content-type': 'application/json',
                    accept: 'application/graphql-response+json',
                },
                body: JSON.stringify({
                    query: '{ 8f31403dfe404bccbb0e835f2629c6a7 }', // making sure the field doesnt exist
                }),
            });
            (0, utils_1.assert)('Data entry', (await (0, utils_1.assertBodyAsExecutionResult)(res)).data).toBe(undefined);
        }),
        // TODO: how to fail and have the data entry?
        // audit('MUST use 2xx status code if response contains the data entry and it is not null when accepting application/graphql-response+json'),
        // TODO: how to make an unauthorized request?
        // https://graphql.github.io/graphql-over-http/draft/#sel-EANNNDTAAEVBAAqqc
        // audit('SHOULD use 401 or 403 status codes when the request is not permitted')
    ];
}
exports.serverAudits = serverAudits;
/**
 * Performs the full list of server audits required for GraphQL over HTTP spec conformance.
 *
 * Please consult the `AuditResult` for more information.
 *
 * @category Audits
 */
async function auditServer(opts) {
    const audits = serverAudits(opts);
    // audit tests will throw only on fatal errors, tests are contained within the AuditResult
    return await Promise.all(audits.map(({ fn }) => fn()));
}
exports.auditServer = auditServer;
/** @private */
async function getUrl(url) {
    if (typeof url === 'function') {
        return await url();
    }
    return url;
}
