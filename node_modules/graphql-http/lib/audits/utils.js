"use strict";
/**
 *
 * audit/utils
 *
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.assertBodyAsExecutionResult = exports.assert = exports.audit = void 0;
__exportStar(require("../utils"), exports);
/**
 * Wrap and prepare an audit for testing.
 *
 * @private
 */
function audit(name, fn) {
    return {
        name,
        fn: async () => {
            try {
                await fn();
                return {
                    name,
                    status: 'ok',
                };
            }
            catch (errOrReason) {
                if (typeof errOrReason !== 'string') {
                    // anything thrown that is not an assertion string is considered fatal
                    throw errOrReason;
                }
                return {
                    name,
                    status: name.startsWith('MUST')
                        ? // only failing MUSTs are considered errors
                            'error'
                        : // everything else is optional and considered a warning
                            'warn',
                    reason: errOrReason,
                };
            }
        },
    };
}
exports.audit = audit;
/**
 * Will throw a string if the assertion fails.
 *
 * All fatal problems will throw an instance of Error.
 *
 * @private
 */
function assert(name, actual) {
    return {
        toBe: (expected) => {
            if (actual !== expected) {
                throw `${name} ${actual} is not ${expected}`;
            }
        },
        toBeBetween: (min, max) => {
            if (!(min <= actual && actual <= max)) {
                throw `${name} ${actual} is not between ${min} and ${max}`;
            }
        },
        toContain: (expected) => {
            // @ts-expect-error types will match, otherwise never
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            if (!actual.includes(expected)) {
                throw `${name} ${JSON.stringify(actual)} does not contain ${JSON.stringify(expected)}`;
            }
        },
        notToContain: (expected) => {
            // @ts-expect-error types will match, otherwise never
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            if (actual.includes(expected)) {
                throw `${name} ${JSON.stringify(actual)} contains ${JSON.stringify(expected)}`;
            }
        },
        toHaveProperty: (
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        prop) => {
            // @ts-expect-error types will match, otherwise never
            if (!(prop in actual)) {
                throw `${name} ${JSON.stringify(actual)} does not have a property '${String(prop)}'`;
            }
        },
        notToHaveProperty: (
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        prop) => {
            // @ts-expect-error types will match, otherwise never
            if (prop in actual) {
                throw `${name} ${JSON.stringify(actual)} does have a property '${String(prop)}'`;
            }
        },
    };
}
exports.assert = assert;
/**
 * Parses the string as JSON and safely reports parsing issues for audits.
 *
 * Assumes the parsed JSON will be an `ExecutionResult`.
 *
 * @private
 * */
async function assertBodyAsExecutionResult(res) {
    const str = await res.text();
    try {
        return JSON.parse(str);
    }
    catch (err) {
        throw `Response body is not valid JSON. Got ${JSON.stringify(str)}`;
    }
}
exports.assertBodyAsExecutionResult = assertBodyAsExecutionResult;
