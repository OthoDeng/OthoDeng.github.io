{"version":3,"file":"utils.js","names":["filterHeadProps","input","location","pathname","params","data","pageContext","headExportValidator","head","Error","warnOnce","_","process","env","NODE_ENV","warnings","Set","msg","has","console","warn","add","warnForInvalidTags","tagName","warning","VALID_NODE_NAMES","join","isEqualNode","oldTag","newTag","HTMLElement","nonce","getAttribute","cloneTag","cloneNode","setAttribute","diffNodes","oldNodes","newNodes","onStale","onNew","existingHeadElement","indexInNewNodes","findIndex","e","splice","newNode"],"sources":["../../head/utils.js"],"sourcesContent":["import { VALID_NODE_NAMES } from \"./constants\"\n\n/**\n * Filter the props coming from a page down to just the ones that are relevant for head.\n * This e.g. filters out properties that are undefined during SSR.\n */\nexport function filterHeadProps(input) {\n  return {\n    location: {\n      pathname: input.location.pathname,\n    },\n    params: input.params,\n    data: input.data || {},\n    pageContext: input.pageContext,\n  }\n}\n\n/**\n * Throw error if Head export is not a valid\n */\nexport function headExportValidator(head) {\n  if (typeof head !== `function`)\n    throw new Error(\n      `Expected \"Head\" export to be a function got \"${typeof head}\".`\n    )\n}\n\n/**\n * Warn once for same messsage\n */\nlet warnOnce = _ => {}\nif (process.env.NODE_ENV !== `production`) {\n  const warnings = new Set()\n  warnOnce = msg => {\n    if (!warnings.has(msg)) {\n      console.warn(msg)\n    }\n    warnings.add(msg)\n  }\n}\n\n/**\n * Warn for invalid tags in head.\n * @param {string} tagName\n */\nexport function warnForInvalidTags(tagName) {\n  if (process.env.NODE_ENV !== `production`) {\n    const warning = `<${tagName}> is not a valid head element. Please use one of the following: ${VALID_NODE_NAMES.join(\n      `, `\n    )}`\n\n    warnOnce(warning)\n  }\n}\n\n/**\n * When a `nonce` is present on an element, browsers such as Chrome and Firefox strip it out of the\n * actual HTML attributes for security reasons *when the element is added to the document*. Thus,\n * given two equivalent elements that have nonces, `Element,isEqualNode()` will return false if one\n * of those elements gets added to the document. Although the `element.nonce` property will be the\n * same for both elements, the one that was added to the document will return an empty string for\n * its nonce HTML attribute value.\n *\n * This custom `isEqualNode()` function therefore removes the nonce value from the `newTag` before\n * comparing it to `oldTag`, restoring it afterwards.\n *\n * For more information, see:\n * https://bugs.chromium.org/p/chromium/issues/detail?id=1211471#c12\n */\nexport function isEqualNode(oldTag, newTag) {\n  if (oldTag instanceof HTMLElement && newTag instanceof HTMLElement) {\n    const nonce = newTag.getAttribute(`nonce`)\n    // Only strip the nonce if `oldTag` has had it stripped. An element's nonce attribute will not\n    // be stripped if there is no content security policy response header that includes a nonce.\n    if (nonce && !oldTag.getAttribute(`nonce`)) {\n      const cloneTag = newTag.cloneNode(true)\n      cloneTag.setAttribute(`nonce`, ``)\n      cloneTag.nonce = nonce\n      return nonce === oldTag.nonce && oldTag.isEqualNode(cloneTag)\n    }\n  }\n\n  return oldTag.isEqualNode(newTag)\n}\n\nexport function diffNodes({ oldNodes, newNodes, onStale, onNew }) {\n  for (const existingHeadElement of oldNodes) {\n    const indexInNewNodes = newNodes.findIndex(e =>\n      isEqualNode(e, existingHeadElement)\n    )\n\n    if (indexInNewNodes === -1) {\n      onStale(existingHeadElement)\n    } else {\n      // this node is re-created as-is, so we keep old node, and remove it from list of new nodes (as we handled it already here)\n      newNodes.splice(indexInNewNodes, 1)\n    }\n  }\n\n  // remaing new nodes didn't have matching old node, so need to be added\n  for (const newNode of newNodes) {\n    onNew(newNode)\n  }\n}\n"],"mappings":";;;;;;;;AAAA;AAEA;AACA;AACA;AACA;AACO,SAASA,eAAe,CAACC,KAAK,EAAE;EACrC,OAAO;IACLC,QAAQ,EAAE;MACRC,QAAQ,EAAEF,KAAK,CAACC,QAAQ,CAACC;IAC3B,CAAC;IACDC,MAAM,EAAEH,KAAK,CAACG,MAAM;IACpBC,IAAI,EAAEJ,KAAK,CAACI,IAAI,IAAI,CAAC,CAAC;IACtBC,WAAW,EAAEL,KAAK,CAACK;EACrB,CAAC;AACH;;AAEA;AACA;AACA;AACO,SAASC,mBAAmB,CAACC,IAAI,EAAE;EACxC,IAAI,OAAOA,IAAI,KAAM,UAAS,EAC5B,MAAM,IAAIC,KAAK,CACZ,gDAA+C,OAAOD,IAAK,IAAG,CAChE;AACL;;AAEA;AACA;AACA;AACA,IAAIE,QAAQ,GAAGC,CAAC,IAAI,CAAC,CAAC;AACtB,IAAIC,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAM,YAAW,EAAE;EACzC,MAAMC,QAAQ,GAAG,IAAIC,GAAG,EAAE;EAC1BN,QAAQ,GAAGO,GAAG,IAAI;IAChB,IAAI,CAACF,QAAQ,CAACG,GAAG,CAACD,GAAG,CAAC,EAAE;MACtBE,OAAO,CAACC,IAAI,CAACH,GAAG,CAAC;IACnB;IACAF,QAAQ,CAACM,GAAG,CAACJ,GAAG,CAAC;EACnB,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACO,SAASK,kBAAkB,CAACC,OAAO,EAAE;EAC1C,IAAIX,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAM,YAAW,EAAE;IACzC,MAAMU,OAAO,GAAI,IAAGD,OAAQ,mEAAkEE,2BAAgB,CAACC,IAAI,CAChH,IAAG,CACJ,EAAC;IAEHhB,QAAQ,CAACc,OAAO,CAAC;EACnB;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASG,WAAW,CAACC,MAAM,EAAEC,MAAM,EAAE;EAC1C,IAAID,MAAM,YAAYE,WAAW,IAAID,MAAM,YAAYC,WAAW,EAAE;IAClE,MAAMC,KAAK,GAAGF,MAAM,CAACG,YAAY,CAAE,OAAM,CAAC;IAC1C;IACA;IACA,IAAID,KAAK,IAAI,CAACH,MAAM,CAACI,YAAY,CAAE,OAAM,CAAC,EAAE;MAC1C,MAAMC,QAAQ,GAAGJ,MAAM,CAACK,SAAS,CAAC,IAAI,CAAC;MACvCD,QAAQ,CAACE,YAAY,CAAE,OAAM,EAAG,EAAC,CAAC;MAClCF,QAAQ,CAACF,KAAK,GAAGA,KAAK;MACtB,OAAOA,KAAK,KAAKH,MAAM,CAACG,KAAK,IAAIH,MAAM,CAACD,WAAW,CAACM,QAAQ,CAAC;IAC/D;EACF;EAEA,OAAOL,MAAM,CAACD,WAAW,CAACE,MAAM,CAAC;AACnC;AAEO,SAASO,SAAS,CAAC;EAAEC,QAAQ;EAAEC,QAAQ;EAAEC,OAAO;EAAEC;AAAM,CAAC,EAAE;EAChE,KAAK,MAAMC,mBAAmB,IAAIJ,QAAQ,EAAE;IAC1C,MAAMK,eAAe,GAAGJ,QAAQ,CAACK,SAAS,CAACC,CAAC,IAC1CjB,WAAW,CAACiB,CAAC,EAAEH,mBAAmB,CAAC,CACpC;IAED,IAAIC,eAAe,KAAK,CAAC,CAAC,EAAE;MAC1BH,OAAO,CAACE,mBAAmB,CAAC;IAC9B,CAAC,MAAM;MACL;MACAH,QAAQ,CAACO,MAAM,CAACH,eAAe,EAAE,CAAC,CAAC;IACrC;EACF;;EAEA;EACA,KAAK,MAAMI,OAAO,IAAIR,QAAQ,EAAE;IAC9BE,KAAK,CAACM,OAAO,CAAC;EAChB;AACF"}