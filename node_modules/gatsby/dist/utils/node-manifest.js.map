{"version":3,"file":"node-manifest.js","names":["getNodeManifestFileLimit","defaultLimit","overrideLimit","process","env","NODE_MANIFEST_FILE_LIMIT","Number","findPageOwnedByNode","nodeId","slug","state","store","getState","pages","nodes","byNode","queries","pagePath","get","values","next","value","foundPageBy","ownerPagePath","foundOwnerNodeId","pageObject","path","fullPage","ownerNodeId","foundPageIdInContext","context","id","foundPageSlugInContext","pageCreatedByPluginName","pluginCreatorId","name","pageCreatedByFilesystemPlugin","page","foundPageByToLogIds","none","queryTracking","warnAboutNodeManifestMappingProblems","inputManifest","verbose","logId","reporter","error","Error","processNodeManifest","listOfUniqueErrorIds","nodeManifestPagePathMap","verboseLogs","previouslyWrittenNodeManifests","node","fullNode","getNode","noNodeWarningId","pluginName","add","nodeManifestPage","nodeManifestMappingProblemsContext","finalManifest","gatsbySiteDirectory","program","directory","fileNameBase","manifestId","platform","replace","manifestFilePath","join","manifestFileDir","dirname","fs","ensureDir","previouslyWrittenNodeManifest","shouldWriteManifest","writePromise","writeJSON","set","Promise","resolve","then","info","nodeManifestSortComparerAscendingUpdatedAt","a","b","updatedAtUTC","Date","parse","processNodeManifests","gatsby_log_level","VERBOSE_NODE_MANIFEST","startTime","now","nodeManifests","totalManifests","length","totalProcessedManifests","totalFailedManifests","Map","Set","processNodeManifestTask","manifest","cb","processedManifest","setImmediate","processNodeManifestQueue","fastq","sort","slice","push","idle","drain","pluralize","endTime","size","dispatch","internalActions","deleteNodeManifests"],"sources":["../../src/utils/node-manifest.ts"],"sourcesContent":["import type { ErrorId } from \"gatsby-cli/lib/structured-errors/error-map\"\nimport { getNode } from \"./../datastore\"\nimport { IGatsbyPage, INodeManifest } from \"./../redux/types\"\nimport reporter from \"gatsby-cli/lib/reporter\"\nimport { store } from \"../redux/\"\nimport { internalActions } from \"../redux/actions\"\nimport path from \"path\"\nimport fs from \"fs-extra\"\nimport fastq from \"fastq\"\n\ninterface INodeManifestPage {\n  path?: string\n}\n\n/**\n * This it the output after processing calls to the public unstable_createNodeManifest action\n */\ninterface INodeManifestOut {\n  page: INodeManifestPage\n  node: {\n    id: string\n  }\n  foundPageBy: FoundPageBy\n}\n\ntype FoundPageBy =\n  | `ownerNodeId`\n  | `filesystem-route-api`\n  // for these three we warn to use ownerNodeId instead\n  | `context.id`\n  | `context.slug`\n  | `queryTracking`\n  | `none`\n\ntype PreviouslyWrittenNodeManifests = Map<string, Promise<INodeManifestOut>>\n\nfunction getNodeManifestFileLimit(): number {\n  const defaultLimit = 10000\n\n  const overrideLimit =\n    process.env.NODE_MANIFEST_FILE_LIMIT &&\n    Number(process.env.NODE_MANIFEST_FILE_LIMIT)\n\n  return overrideLimit || defaultLimit\n}\n/**\n * This defines a limit to the number number of node manifest files that will be written to disk\n */\nconst NODE_MANIFEST_FILE_LIMIT = getNodeManifestFileLimit()\n\n/**\n * Finds a final built page by nodeId or by node.slug as a fallback.\n *\n * Note that this function wont work properly in `gatsby develop`\n * since develop no longer runs all page queries when creating pages.\n * We use the node id to query mapping to find the right page but\n * this mapping only exists once you've visited a page in your browser.\n * When this fn is being used for routing to previews the user wont necessarily have\n * visited the page in the browser yet.\n */\nasync function findPageOwnedByNode({\n  nodeId,\n  slug,\n}: {\n  nodeId: string\n  slug?: string\n}): Promise<{\n  page: INodeManifestPage\n  foundPageBy: FoundPageBy\n}> {\n  const state = store.getState()\n  const { pages, nodes } = state\n  const { byNode } = state.queries\n\n  // the default page path is the first page found in\n  // node id to page query tracking\n  let pagePath = byNode?.get(nodeId)?.values()?.next()?.value\n\n  let foundPageBy: FoundPageBy = pagePath ? `queryTracking` : `none`\n\n  if (pages) {\n    let ownerPagePath: string | undefined\n    let foundOwnerNodeId = false\n\n    // for each page this nodeId is queried in\n    for (const pageObject of pages.values()) {\n      // if we haven't found a page with this nodeId\n      // set as page.ownerNodeId then run this logic.\n      // this condition is on foundOwnerNodeId instead of ownerPagePath\n      // in case we find a page with the nodeId in page.context.id/context.slug\n      // and then later in the loop there's a page with this nodeId\n      // set on page.ownerNodeId.\n      // We always want to prefer ownerPagePath over context.id/context.slug\n      if (foundOwnerNodeId) {\n        break\n      }\n\n      const path = pageObject.path\n\n      const fullPage: IGatsbyPage | undefined = pages.get(path)\n\n      foundOwnerNodeId = fullPage?.ownerNodeId === nodeId\n\n      const foundPageIdInContext = fullPage?.context?.id === nodeId\n\n      // querying by node.slug in GraphQL queries is common enough that we can search for it as a fallback after ownerNodeId, filesystem routes, and context.id\n      const foundPageSlugInContext = slug && fullPage?.context?.slug === slug\n\n      if (foundOwnerNodeId) {\n        foundPageBy = `ownerNodeId`\n      } else if (foundPageIdInContext && fullPage) {\n        const pageCreatedByPluginName = nodes.get(\n          fullPage.pluginCreatorId\n        )?.name\n\n        const pageCreatedByFilesystemPlugin =\n          pageCreatedByPluginName === `gatsby-plugin-page-creator`\n\n        foundPageBy = pageCreatedByFilesystemPlugin\n          ? `filesystem-route-api`\n          : `context.id`\n      } else if (foundPageSlugInContext && fullPage) {\n        foundPageBy = `context.slug`\n      }\n\n      if (\n        fullPage &&\n        // first check for the ownerNodeId on the page. this is\n        // the defacto owner. Can't get more specific than this\n        (foundOwnerNodeId ||\n          // if there's no specified owner look to see if\n          // pageContext has an `id` variable which matches our\n          // nodeId. Using an \"id\" as a variable in queries is common\n          // and if we don't have an owner this is a better guess\n          // of an owner than grabbing the first page query we find\n          // that's mapped to this node id.\n          // this also makes this work with the filesystem Route API without\n          // changing that API.\n          foundPageIdInContext ||\n          foundPageSlugInContext)\n      ) {\n        // save this path to use in our manifest!\n        ownerPagePath = fullPage.path\n      }\n    }\n\n    if (ownerPagePath) {\n      pagePath = ownerPagePath\n    }\n  }\n\n  return {\n    page: {\n      path: pagePath || null,\n    },\n    foundPageBy,\n  }\n}\n\n// these id's correspond to error id's in\n// packages/gatsby-cli/src/structured-errors/error-map.ts\nexport const foundPageByToLogIds = {\n  none: `11801`,\n  [`context.id`]: `11802`,\n  [`context.slug`]: `11805`,\n  queryTracking: `11803`,\n  [`filesystem-route-api`]: `success`,\n  ownerNodeId: `success`,\n}\n\n/**\n * Takes in some info about a node manifest and the page we did or didn't find for it, then warns and returns the warning string\n */\nexport function warnAboutNodeManifestMappingProblems({\n  inputManifest,\n  pagePath,\n  foundPageBy,\n  verbose,\n}: {\n  inputManifest: INodeManifest\n  pagePath?: string\n  foundPageBy: FoundPageBy\n  verbose: boolean\n}): { logId: string } {\n  let logId: ErrorId | `success`\n\n  switch (foundPageBy) {\n    case `none`:\n    case `context.id`:\n    case `context.slug`:\n    case `queryTracking`: {\n      logId = foundPageByToLogIds[foundPageBy]\n      if (verbose) {\n        reporter.error({\n          id: logId,\n          context: {\n            inputManifest,\n            pagePath,\n          },\n        })\n      }\n      break\n    }\n\n    case `filesystem-route-api`:\n    case `ownerNodeId`:\n      logId = `success`\n      break\n\n    default: {\n      throw Error(`Node Manifest mapping is in an impossible state`)\n    }\n  }\n\n  return {\n    logId,\n  }\n}\n\n/**\n * Prepares and then writes out an individual node manifest file to be used for routing to previews. Manifest files are added via the public unstable_createNodeManifest action\n */\nexport async function processNodeManifest(\n  inputManifest: INodeManifest,\n  listOfUniqueErrorIds: Set<string>,\n  nodeManifestPagePathMap: Map<string, string>,\n  verboseLogs: boolean,\n  previouslyWrittenNodeManifests: PreviouslyWrittenNodeManifests\n): Promise<null | INodeManifestOut> {\n  const nodeId = inputManifest.node.id\n  const fullNode = getNode(nodeId)\n  const noNodeWarningId = `11804`\n\n  if (!fullNode) {\n    if (verboseLogs) {\n      reporter.error({\n        id: noNodeWarningId,\n        context: {\n          pluginName: inputManifest.pluginName,\n          nodeId,\n        },\n      })\n    } else {\n      listOfUniqueErrorIds.add(noNodeWarningId)\n    }\n\n    return null\n  }\n\n  // map the node to a page that was created\n  const { page: nodeManifestPage, foundPageBy } = await findPageOwnedByNode({\n    nodeId,\n    // querying by node.slug in GraphQL queries is common enough that we can search for it as a fallback after ownerNodeId, filesystem routes, and context.id\n    slug: fullNode?.slug as string,\n  })\n\n  const nodeManifestMappingProblemsContext = {\n    inputManifest,\n    pagePath: nodeManifestPage.path,\n    foundPageBy,\n    verbose: verboseLogs,\n  }\n\n  if (verboseLogs) {\n    warnAboutNodeManifestMappingProblems(nodeManifestMappingProblemsContext)\n  } else {\n    const { logId } = warnAboutNodeManifestMappingProblems(\n      nodeManifestMappingProblemsContext\n    )\n\n    if (logId !== `success`) {\n      listOfUniqueErrorIds.add(logId)\n    }\n  }\n\n  const finalManifest: INodeManifestOut = {\n    node: inputManifest.node,\n    page: nodeManifestPage,\n    foundPageBy,\n  }\n\n  const gatsbySiteDirectory = store.getState().program.directory\n\n  let fileNameBase = inputManifest.manifestId\n\n  /**\n   * Windows has a handful of special/reserved characters that are not valid in a file path\n   * @reference https://superuser.com/questions/358855/what-characters-are-safe-in-cross-platform-file-names-for-linux-windows-and-os\n   *\n   * The two exceptions to the list linked above are\n   * - the colon that is part of the hard disk partition name at the beginning of a file path (i.e. C:)\n   * - backslashes. We don't want to replace backslashes because those are used to delineate what the actual file path is\n   *\n   * During local development, node manifests can be written to disk but are generally unused as they are only used\n   * for Content Sync which runs in Gatsby Cloud. Gatsby cloud is a Linux environment in which these special chars are valid in\n   * filepaths. To avoid errors on Windows, we replace all instances of the special chars in the filepath (with the exception of the\n   * hard disk partition name) with \"-\" to ensure that local Windows development setups do not break when attempting\n   * to write one of these manifests to disk.\n   */\n  if (process.platform === `win32`) {\n    fileNameBase = fileNameBase.replace(/:|\\/|\\*|\\?|\"|<|>|\\||\\\\/g, `-`)\n  }\n\n  // write out the manifest file\n  const manifestFilePath = path.join(\n    gatsbySiteDirectory,\n    `public`,\n    `__node-manifests`,\n    inputManifest.pluginName,\n    `${fileNameBase}.json`\n  )\n\n  const manifestFileDir = path.dirname(manifestFilePath)\n\n  await fs.ensureDir(manifestFileDir)\n\n  const previouslyWrittenNodeManifest =\n    await previouslyWrittenNodeManifests.get(inputManifest.manifestId)\n\n  // write a manifest if we don't currently have one written for this ID\n  // or if we can replace the written one with a manifest that has found a page\n  // NOTE: We still want to write out a manifest if foundPageBy is \"none\", this helps with error messaging\n  //       But we prefer to write a manifest that has a foundPageBy that is NOT \"none\"\n  const shouldWriteManifest =\n    !previouslyWrittenNodeManifest ||\n    (previouslyWrittenNodeManifest?.foundPageBy === `none` &&\n      finalManifest.foundPageBy !== `none`)\n\n  if (shouldWriteManifest) {\n    const writePromise = fs.writeJSON(manifestFilePath, finalManifest)\n\n    // This prevents two manifests from writing to the same file at the same time\n    previouslyWrittenNodeManifests.set(\n      inputManifest.manifestId,\n      new Promise(resolve => {\n        writePromise.then(() => {\n          resolve(finalManifest)\n        })\n      })\n    )\n\n    await writePromise\n  }\n\n  if (shouldWriteManifest && verboseLogs) {\n    reporter.info(\n      `Plugin ${inputManifest.pluginName} created a manifest with the id ${fileNameBase}`\n    )\n  } else if (verboseLogs) {\n    reporter.info(\n      `Plugin ${inputManifest.pluginName} created a manifest with the id ${fileNameBase} but it was not written to disk because it was already written to disk previously.`\n    )\n  }\n\n  if (nodeManifestPage.path) {\n    nodeManifestPagePathMap.set(nodeManifestPage.path, fileNameBase)\n  }\n\n  return finalManifest\n}\n\nfunction nodeManifestSortComparerAscendingUpdatedAt(a, b): number {\n  /**\n   * Prioritize node manifests that have an updatedAtUTC so that manifests known to be\n   * newest are written to disk first. If neither have an updatedAtUTC, there isn't\n   * anything to sort\n   */\n  if (!a.updatedAtUTC && !b.updatedAtUTC) {\n    return 0\n  }\n\n  if (!a.updatedAtUTC) {\n    return 1\n  }\n\n  if (!b.updatedAtUTC) {\n    return -1\n  }\n\n  return Date.parse(a.updatedAtUTC) - Date.parse(b.updatedAtUTC)\n}\n\n/**\n * Grabs all pending node manifests, processes them, writes them to disk,\n * and then removes them from the store.\n * Manifest files are added via the public unstable_createNodeManifest action in sourceNodes\n */\nexport async function processNodeManifests(): Promise<Map<\n  string,\n  string\n> | null> {\n  const verboseLogs =\n    process.env.gatsby_log_level === `verbose` ||\n    process.env.VERBOSE_NODE_MANIFEST === `true`\n\n  const startTime = Date.now()\n  let { nodeManifests } = store.getState()\n\n  const totalManifests = nodeManifests.length\n\n  if (totalManifests === 0) {\n    return null\n  }\n\n  let totalProcessedManifests = 0\n  let totalFailedManifests = 0\n  const nodeManifestPagePathMap: Map<string, string> = new Map()\n  const listOfUniqueErrorIds: Set<string> = new Set()\n  const previouslyWrittenNodeManifests: PreviouslyWrittenNodeManifests =\n    new Map()\n\n  async function processNodeManifestTask(\n    manifest: INodeManifest,\n    cb: fastq.done<any>\n  ): Promise<void> {\n    const processedManifest = await processNodeManifest(\n      manifest,\n      listOfUniqueErrorIds,\n      nodeManifestPagePathMap,\n      verboseLogs,\n      previouslyWrittenNodeManifests\n    )\n\n    if (processedManifest) {\n      totalProcessedManifests++\n    } else {\n      totalFailedManifests++\n    }\n\n    // `setImmediate` below is a workaround against stack overflow\n    // occurring when there are many manifests\n    setImmediate(() => cb(null, true))\n    return\n  }\n\n  const processNodeManifestQueue = fastq(processNodeManifestTask, 25)\n\n  if (totalManifests > NODE_MANIFEST_FILE_LIMIT) {\n    nodeManifests = [...nodeManifests]\n    nodeManifests.sort(nodeManifestSortComparerAscendingUpdatedAt)\n    nodeManifests = nodeManifests.slice(0, NODE_MANIFEST_FILE_LIMIT)\n  }\n\n  for (const manifest of nodeManifests) {\n    processNodeManifestQueue.push(manifest, () => {})\n  }\n\n  if (!processNodeManifestQueue.idle()) {\n    await new Promise(resolve => {\n      processNodeManifestQueue.drain = resolve as () => unknown\n    })\n  }\n\n  const pluralize = (length: number): string =>\n    length > 1 || length === 0 ? `s` : ``\n\n  const endTime = Date.now()\n\n  reporter.info(\n    `Wrote out ${totalProcessedManifests} node page manifest file${pluralize(\n      totalProcessedManifests\n    )} in ${endTime - startTime} ms. ${\n      totalFailedManifests > 0\n        ? `. ${totalFailedManifests} manifest${pluralize(\n            totalFailedManifests\n          )} couldn't be processed.`\n        : ``\n    }`\n  )\n\n  reporter.info(\n    (!verboseLogs && listOfUniqueErrorIds.size > 0\n      ? `unstable_createNodeManifest produced warnings [${[\n          ...listOfUniqueErrorIds,\n        ].join(`, `)}]. `\n      : ``) +\n      `To see full warning messages set process.env.VERBOSE_NODE_MANIFEST to \"true\".\\nVisit https://gatsby.dev/nodemanifest for more info on Node Manifests.`\n  )\n\n  // clean up all pending manifests from the store\n  store.dispatch(internalActions.deleteNodeManifests())\n  return nodeManifestPagePathMap\n}\n"],"mappings":"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"}