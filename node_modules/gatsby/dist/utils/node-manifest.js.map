{"version":3,"file":"node-manifest.js","names":["getNodeManifestFileLimit","defaultLimit","overrideLimit","process","env","NODE_MANIFEST_FILE_LIMIT","Number","findPageOwnedByNode","nodeId","slug","state","store","getState","pages","nodes","byNode","queries","pagePath","get","values","next","value","foundPageBy","ownerPagePath","foundOwnerNodeId","pageObject","path","fullPage","ownerNodeId","foundPageIdInContext","context","id","foundPageSlugInContext","pageCreatedByPluginName","pluginCreatorId","name","pageCreatedByFilesystemPlugin","page","foundPageByToLogIds","none","queryTracking","warnAboutNodeManifestMappingProblems","inputManifest","verbose","logId","reporter","error","Error","processNodeManifest","listOfUniqueErrorIds","nodeManifestPagePathMap","verboseLogs","node","fullNode","getNode","noNodeWarningId","pluginName","add","nodeManifestPage","nodeManifestMappingProblemsContext","finalManifest","gatsbySiteDirectory","program","directory","fileNameBase","manifestId","platform","replace","manifestFilePath","join","manifestFileDir","dirname","fs","ensureDir","writeJSON","info","set","nodeManifestSortComparerAscendingUpdatedAt","a","b","updatedAtUTC","Date","parse","processNodeManifests","gatsby_log_level","VERBOSE_NODE_MANIFEST","startTime","now","nodeManifests","totalManifests","length","totalProcessedManifests","totalFailedManifests","Map","Set","processNodeManifestTask","manifest","cb","processedManifest","setImmediate","processNodeManifestQueue","fastq","sort","slice","push","idle","Promise","resolve","drain","pluralize","endTime","size","dispatch","internalActions","deleteNodeManifests"],"sources":["../../src/utils/node-manifest.ts"],"sourcesContent":["import type { ErrorId } from \"gatsby-cli/lib/structured-errors/error-map\"\nimport { getNode } from \"./../datastore\"\nimport { IGatsbyPage, INodeManifest } from \"./../redux/types\"\nimport reporter from \"gatsby-cli/lib/reporter\"\nimport { store } from \"../redux/\"\nimport { internalActions } from \"../redux/actions\"\nimport path from \"path\"\nimport fs from \"fs-extra\"\nimport fastq from \"fastq\"\n\ninterface INodeManifestPage {\n  path?: string\n}\n\n/**\n * This it the output after processing calls to the public unstable_createNodeManifest action\n */\ninterface INodeManifestOut {\n  page: INodeManifestPage\n  node: {\n    id: string\n  }\n  foundPageBy: FoundPageBy\n}\n\ntype FoundPageBy =\n  | `ownerNodeId`\n  | `filesystem-route-api`\n  // for these three we warn to use ownerNodeId instead\n  | `context.id`\n  | `context.slug`\n  | `queryTracking`\n  | `none`\n\nfunction getNodeManifestFileLimit(): number {\n  const defaultLimit = 10000\n\n  const overrideLimit =\n    process.env.NODE_MANIFEST_FILE_LIMIT &&\n    Number(process.env.NODE_MANIFEST_FILE_LIMIT)\n\n  return overrideLimit || defaultLimit\n}\n/**\n * This defines a limit to the number number of node manifest files that will be written to disk\n */\nconst NODE_MANIFEST_FILE_LIMIT = getNodeManifestFileLimit()\n\n/**\n * Finds a final built page by nodeId or by node.slug as a fallback.\n *\n * Note that this function wont work properly in `gatsby develop`\n * since develop no longer runs all page queries when creating pages.\n * We use the node id to query mapping to find the right page but\n * this mapping only exists once you've visited a page in your browser.\n * When this fn is being used for routing to previews the user wont necessarily have\n * visited the page in the browser yet.\n */\nasync function findPageOwnedByNode({\n  nodeId,\n  slug,\n}: {\n  nodeId: string\n  slug?: string\n}): Promise<{\n  page: INodeManifestPage\n  foundPageBy: FoundPageBy\n}> {\n  const state = store.getState()\n  const { pages, nodes } = state\n  const { byNode } = state.queries\n\n  // the default page path is the first page found in\n  // node id to page query tracking\n  let pagePath = byNode?.get(nodeId)?.values()?.next()?.value\n\n  let foundPageBy: FoundPageBy = pagePath ? `queryTracking` : `none`\n\n  if (pages) {\n    let ownerPagePath: string | undefined\n    let foundOwnerNodeId = false\n\n    // for each page this nodeId is queried in\n    for (const pageObject of pages.values()) {\n      // if we haven't found a page with this nodeId\n      // set as page.ownerNodeId then run this logic.\n      // this condition is on foundOwnerNodeId instead of ownerPagePath\n      // in case we find a page with the nodeId in page.context.id/context.slug\n      // and then later in the loop there's a page with this nodeId\n      // set on page.ownerNodeId.\n      // We always want to prefer ownerPagePath over context.id/context.slug\n      if (foundOwnerNodeId) {\n        break\n      }\n\n      const path = pageObject.path\n\n      const fullPage: IGatsbyPage | undefined = pages.get(path)\n\n      foundOwnerNodeId = fullPage?.ownerNodeId === nodeId\n\n      const foundPageIdInContext = fullPage?.context?.id === nodeId\n\n      // querying by node.slug in GraphQL queries is common enough that we can search for it as a fallback after ownerNodeId, filesystem routes, and context.id\n      const foundPageSlugInContext = slug && fullPage?.context?.slug === slug\n\n      if (foundOwnerNodeId) {\n        foundPageBy = `ownerNodeId`\n      } else if (foundPageIdInContext && fullPage) {\n        const pageCreatedByPluginName = nodes.get(\n          fullPage.pluginCreatorId\n        )?.name\n\n        const pageCreatedByFilesystemPlugin =\n          pageCreatedByPluginName === `gatsby-plugin-page-creator`\n\n        foundPageBy = pageCreatedByFilesystemPlugin\n          ? `filesystem-route-api`\n          : `context.id`\n      } else if (foundPageSlugInContext && fullPage) {\n        foundPageBy = `context.slug`\n      }\n\n      if (\n        fullPage &&\n        // first check for the ownerNodeId on the page. this is\n        // the defacto owner. Can't get more specific than this\n        (foundOwnerNodeId ||\n          // if there's no specified owner look to see if\n          // pageContext has an `id` variable which matches our\n          // nodeId. Using an \"id\" as a variable in queries is common\n          // and if we don't have an owner this is a better guess\n          // of an owner than grabbing the first page query we find\n          // that's mapped to this node id.\n          // this also makes this work with the filesystem Route API without\n          // changing that API.\n          foundPageIdInContext ||\n          foundPageSlugInContext)\n      ) {\n        // save this path to use in our manifest!\n        ownerPagePath = fullPage.path\n      }\n    }\n\n    if (ownerPagePath) {\n      pagePath = ownerPagePath\n    }\n  }\n\n  return {\n    page: {\n      path: pagePath || null,\n    },\n    foundPageBy,\n  }\n}\n\n// these id's correspond to error id's in\n// packages/gatsby-cli/src/structured-errors/error-map.ts\nexport const foundPageByToLogIds = {\n  none: `11801`,\n  [`context.id`]: `11802`,\n  [`context.slug`]: `11805`,\n  queryTracking: `11803`,\n  [`filesystem-route-api`]: `success`,\n  ownerNodeId: `success`,\n}\n\n/**\n * Takes in some info about a node manifest and the page we did or didn't find for it, then warns and returns the warning string\n */\nexport function warnAboutNodeManifestMappingProblems({\n  inputManifest,\n  pagePath,\n  foundPageBy,\n  verbose,\n}: {\n  inputManifest: INodeManifest\n  pagePath?: string\n  foundPageBy: FoundPageBy\n  verbose: boolean\n}): { logId: string } {\n  let logId: ErrorId | `success`\n\n  switch (foundPageBy) {\n    case `none`:\n    case `context.id`:\n    case `context.slug`:\n    case `queryTracking`: {\n      logId = foundPageByToLogIds[foundPageBy]\n      if (verbose) {\n        reporter.error({\n          id: logId,\n          context: {\n            inputManifest,\n            pagePath,\n          },\n        })\n      }\n      break\n    }\n\n    case `filesystem-route-api`:\n    case `ownerNodeId`:\n      logId = `success`\n      break\n\n    default: {\n      throw Error(`Node Manifest mapping is in an impossible state`)\n    }\n  }\n\n  return {\n    logId,\n  }\n}\n\n/**\n * Prepares and then writes out an individual node manifest file to be used for routing to previews. Manifest files are added via the public unstable_createNodeManifest action\n */\nexport async function processNodeManifest(\n  inputManifest: INodeManifest,\n  listOfUniqueErrorIds: Set<string>,\n  nodeManifestPagePathMap: Map<string, string>,\n  verboseLogs: boolean\n): Promise<null | INodeManifestOut> {\n  const nodeId = inputManifest.node.id\n  const fullNode = getNode(nodeId)\n  const noNodeWarningId = `11804`\n\n  if (!fullNode) {\n    if (verboseLogs) {\n      reporter.error({\n        id: noNodeWarningId,\n        context: {\n          pluginName: inputManifest.pluginName,\n          nodeId,\n        },\n      })\n    } else {\n      listOfUniqueErrorIds.add(noNodeWarningId)\n    }\n\n    return null\n  }\n\n  // map the node to a page that was created\n  const { page: nodeManifestPage, foundPageBy } = await findPageOwnedByNode({\n    nodeId,\n    // querying by node.slug in GraphQL queries is common enough that we can search for it as a fallback after ownerNodeId, filesystem routes, and context.id\n    slug: fullNode?.slug as string,\n  })\n\n  const nodeManifestMappingProblemsContext = {\n    inputManifest,\n    pagePath: nodeManifestPage.path,\n    foundPageBy,\n    verbose: verboseLogs,\n  }\n\n  if (verboseLogs) {\n    warnAboutNodeManifestMappingProblems(nodeManifestMappingProblemsContext)\n  } else {\n    const { logId } = warnAboutNodeManifestMappingProblems(\n      nodeManifestMappingProblemsContext\n    )\n\n    if (logId !== `success`) {\n      listOfUniqueErrorIds.add(logId)\n    }\n  }\n\n  const finalManifest: INodeManifestOut = {\n    node: inputManifest.node,\n    page: nodeManifestPage,\n    foundPageBy,\n  }\n\n  const gatsbySiteDirectory = store.getState().program.directory\n\n  let fileNameBase = inputManifest.manifestId\n\n  /**\n   * Windows has a handful of special/reserved characters that are not valid in a file path\n   * @reference https://superuser.com/questions/358855/what-characters-are-safe-in-cross-platform-file-names-for-linux-windows-and-os\n   *\n   * The two exceptions to the list linked above are\n   * - the colon that is part of the hard disk partition name at the beginning of a file path (i.e. C:)\n   * - backslashes. We don't want to replace backslashes because those are used to delineate what the actual file path is\n   *\n   * During local development, node manifests can be written to disk but are generally unused as they are only used\n   * for Content Sync which runs in Gatsby Cloud. Gatsby cloud is a Linux environment in which these special chars are valid in\n   * filepaths. To avoid errors on Windows, we replace all instances of the special chars in the filepath (with the exception of the\n   * hard disk partition name) with \"-\" to ensure that local Windows development setups do not break when attempting\n   * to write one of these manifests to disk.\n   */\n  if (process.platform === `win32`) {\n    fileNameBase = fileNameBase.replace(/:|\\/|\\*|\\?|\"|<|>|\\||\\\\/g, `-`)\n  }\n\n  // write out the manifest file\n  const manifestFilePath = path.join(\n    gatsbySiteDirectory,\n    `public`,\n    `__node-manifests`,\n    inputManifest.pluginName,\n    `${fileNameBase}.json`\n  )\n\n  const manifestFileDir = path.dirname(manifestFilePath)\n\n  await fs.ensureDir(manifestFileDir)\n  await fs.writeJSON(manifestFilePath, finalManifest)\n\n  if (verboseLogs) {\n    reporter.info(\n      `Plugin ${inputManifest.pluginName} created a manifest with the id ${fileNameBase}`\n    )\n  }\n\n  if (nodeManifestPage.path) {\n    nodeManifestPagePathMap.set(nodeManifestPage.path, fileNameBase)\n  }\n\n  return finalManifest\n}\n\nfunction nodeManifestSortComparerAscendingUpdatedAt(a, b): number {\n  /**\n   * Prioritize node manifests that have an updatedAtUTC so that manifests known to be\n   * newest are written to disk first. If neither have an updatedAtUTC, there isn't\n   * anything to sort\n   */\n  if (!a.updatedAtUTC && !b.updatedAtUTC) {\n    return 0\n  }\n\n  if (!a.updatedAtUTC) {\n    return 1\n  }\n\n  if (!b.updatedAtUTC) {\n    return -1\n  }\n\n  return Date.parse(a.updatedAtUTC) - Date.parse(b.updatedAtUTC)\n}\n\n/**\n * Grabs all pending node manifests, processes them, writes them to disk,\n * and then removes them from the store.\n * Manifest files are added via the public unstable_createNodeManifest action in sourceNodes\n */\nexport async function processNodeManifests(): Promise<Map<\n  string,\n  string\n> | null> {\n  const verboseLogs =\n    process.env.gatsby_log_level === `verbose` ||\n    process.env.VERBOSE_NODE_MANIFEST === `true`\n\n  const startTime = Date.now()\n  let { nodeManifests } = store.getState()\n\n  const totalManifests = nodeManifests.length\n\n  if (totalManifests === 0) {\n    return null\n  }\n\n  let totalProcessedManifests = 0\n  let totalFailedManifests = 0\n  const nodeManifestPagePathMap: Map<string, string> = new Map()\n  const listOfUniqueErrorIds: Set<string> = new Set()\n\n  async function processNodeManifestTask(\n    manifest: INodeManifest,\n    cb: fastq.done<any>\n  ): Promise<void> {\n    const processedManifest = await processNodeManifest(\n      manifest,\n      listOfUniqueErrorIds,\n      nodeManifestPagePathMap,\n      verboseLogs\n    )\n\n    if (processedManifest) {\n      totalProcessedManifests++\n    } else {\n      totalFailedManifests++\n    }\n\n    // `setImmediate` below is a workaround against stack overflow\n    // occurring when there are many manifests\n    setImmediate(() => cb(null, true))\n    return\n  }\n\n  const processNodeManifestQueue = fastq(processNodeManifestTask, 25)\n\n  if (totalManifests > NODE_MANIFEST_FILE_LIMIT) {\n    nodeManifests = [...nodeManifests]\n    nodeManifests.sort(nodeManifestSortComparerAscendingUpdatedAt)\n    nodeManifests = nodeManifests.slice(0, NODE_MANIFEST_FILE_LIMIT)\n  }\n\n  for (const manifest of nodeManifests) {\n    processNodeManifestQueue.push(manifest, () => {})\n  }\n\n  if (!processNodeManifestQueue.idle()) {\n    await new Promise(resolve => {\n      processNodeManifestQueue.drain = resolve as () => unknown\n    })\n  }\n\n  const pluralize = (length: number): string =>\n    length > 1 || length === 0 ? `s` : ``\n\n  const endTime = Date.now()\n\n  reporter.info(\n    `Wrote out ${totalProcessedManifests} node page manifest file${pluralize(\n      totalProcessedManifests\n    )} in ${endTime - startTime} ms. ${\n      totalFailedManifests > 0\n        ? `. ${totalFailedManifests} manifest${pluralize(\n            totalFailedManifests\n          )} couldn't be processed.`\n        : ``\n    }`\n  )\n\n  reporter.info(\n    (!verboseLogs && listOfUniqueErrorIds.size > 0\n      ? `unstable_createNodeManifest produced warnings [${[\n          ...listOfUniqueErrorIds,\n        ].join(`, `)}]. `\n      : ``) +\n      `To see full warning messages set process.env.VERBOSE_NODE_MANIFEST to \"true\".\\nVisit https://gatsby.dev/nodemanifest for more info on Node Manifests.`\n  )\n\n  // clean up all pending manifests from the store\n  store.dispatch(internalActions.deleteNodeManifests())\n  return nodeManifestPagePathMap\n}\n"],"mappings":";;;;;;;;;;AACA;;AAEA;;AACA;;AACA;;AACA;;AACA;;AACA;;AA0BA,SAASA,wBAAT,GAA4C;EAC1C,MAAMC,YAAY,GAAG,KAArB;EAEA,MAAMC,aAAa,GACjBC,OAAO,CAACC,GAAR,CAAYC,wBAAZ,IACAC,MAAM,CAACH,OAAO,CAACC,GAAR,CAAYC,wBAAb,CAFR;EAIA,OAAOH,aAAa,IAAID,YAAxB;AACD;AACD;AACA;AACA;;;AACA,MAAMI,wBAAwB,GAAGL,wBAAwB,EAAzD;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAeO,mBAAf,CAAmC;EACjCC,MADiC;EAEjCC;AAFiC,CAAnC,EASG;EAAA;;EACD,MAAMC,KAAK,GAAGC,YAAA,CAAMC,QAAN,EAAd;;EACA,MAAM;IAAEC,KAAF;IAASC;EAAT,IAAmBJ,KAAzB;EACA,MAAM;IAAEK;EAAF,IAAaL,KAAK,CAACM,OAAzB,CAHC,CAKD;EACA;;EACA,IAAIC,QAAQ,GAAGF,MAAH,aAAGA,MAAH,sCAAGA,MAAM,CAAEG,GAAR,CAAYV,MAAZ,CAAH,sEAAG,YAAqBW,MAArB,EAAH,gFAAG,mBAA+BC,IAA/B,EAAH,0DAAG,sBAAuCC,KAAtD;EAEA,IAAIC,WAAwB,GAAGL,QAAQ,GAAI,eAAJ,GAAsB,MAA7D;;EAEA,IAAIJ,KAAJ,EAAW;IACT,IAAIU,aAAJ;IACA,IAAIC,gBAAgB,GAAG,KAAvB,CAFS,CAIT;;IACA,KAAK,MAAMC,UAAX,IAAyBZ,KAAK,CAACM,MAAN,EAAzB,EAAyC;MAAA;;MACvC;MACA;MACA;MACA;MACA;MACA;MACA;MACA,IAAIK,gBAAJ,EAAsB;QACpB;MACD;;MAED,MAAME,IAAI,GAAGD,UAAU,CAACC,IAAxB;MAEA,MAAMC,QAAiC,GAAGd,KAAK,CAACK,GAAN,CAAUQ,IAAV,CAA1C;MAEAF,gBAAgB,GAAG,CAAAG,QAAQ,SAAR,IAAAA,QAAQ,WAAR,YAAAA,QAAQ,CAAEC,WAAV,MAA0BpB,MAA7C;MAEA,MAAMqB,oBAAoB,GAAG,CAAAF,QAAQ,SAAR,IAAAA,QAAQ,WAAR,iCAAAA,QAAQ,CAAEG,OAAV,wEAAmBC,EAAnB,MAA0BvB,MAAvD,CAlBuC,CAoBvC;;MACA,MAAMwB,sBAAsB,GAAGvB,IAAI,IAAI,CAAAkB,QAAQ,SAAR,IAAAA,QAAQ,WAAR,kCAAAA,QAAQ,CAAEG,OAAV,0EAAmBrB,IAAnB,MAA4BA,IAAnE;;MAEA,IAAIe,gBAAJ,EAAsB;QACpBF,WAAW,GAAI,aAAf;MACD,CAFD,MAEO,IAAIO,oBAAoB,IAAIF,QAA5B,EAAsC;QAAA;;QAC3C,MAAMM,uBAAuB,iBAAGnB,KAAK,CAACI,GAAN,CAC9BS,QAAQ,CAACO,eADqB,CAAH,+CAAG,WAE7BC,IAFH;QAIA,MAAMC,6BAA6B,GACjCH,uBAAuB,KAAM,4BAD/B;QAGAX,WAAW,GAAGc,6BAA6B,GACtC,sBADsC,GAEtC,YAFL;MAGD,CAXM,MAWA,IAAIJ,sBAAsB,IAAIL,QAA9B,EAAwC;QAC7CL,WAAW,GAAI,cAAf;MACD;;MAED,IACEK,QAAQ,MACR;MACA;MACCH,gBAAgB,IACf;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACAK,oBATD,IAUCG,sBAbM,CADV,EAeE;QACA;QACAT,aAAa,GAAGI,QAAQ,CAACD,IAAzB;MACD;IACF;;IAED,IAAIH,aAAJ,EAAmB;MACjBN,QAAQ,GAAGM,aAAX;IACD;EACF;;EAED,OAAO;IACLc,IAAI,EAAE;MACJX,IAAI,EAAET,QAAQ,IAAI;IADd,CADD;IAILK;EAJK,CAAP;AAMD,C,CAED;AACA;;;AACO,MAAMgB,mBAAmB,GAAG;EACjCC,IAAI,EAAG,OAD0B;EAEjC,CAAE,YAAF,GAAiB,OAFgB;EAGjC,CAAE,cAAF,GAAmB,OAHc;EAIjCC,aAAa,EAAG,OAJiB;EAKjC,CAAE,sBAAF,GAA2B,SALM;EAMjCZ,WAAW,EAAG;AANmB,CAA5B;AASP;AACA;AACA;;;;AACO,SAASa,oCAAT,CAA8C;EACnDC,aADmD;EAEnDzB,QAFmD;EAGnDK,WAHmD;EAInDqB;AAJmD,CAA9C,EAUe;EACpB,IAAIC,KAAJ;;EAEA,QAAQtB,WAAR;IACE,KAAM,MAAN;IACA,KAAM,YAAN;IACA,KAAM,cAAN;IACA,KAAM,eAAN;MAAsB;QACpBsB,KAAK,GAAGN,mBAAmB,CAAChB,WAAD,CAA3B;;QACA,IAAIqB,OAAJ,EAAa;UACXE,iBAAA,CAASC,KAAT,CAAe;YACbf,EAAE,EAAEa,KADS;YAEbd,OAAO,EAAE;cACPY,aADO;cAEPzB;YAFO;UAFI,CAAf;QAOD;;QACD;MACD;;IAED,KAAM,sBAAN;IACA,KAAM,aAAN;MACE2B,KAAK,GAAI,SAAT;MACA;;IAEF;MAAS;QACP,MAAMG,KAAK,CAAE,iDAAF,CAAX;MACD;EAzBH;;EA4BA,OAAO;IACLH;EADK,CAAP;AAGD;AAED;AACA;AACA;;;AACO,eAAeI,mBAAf,CACLN,aADK,EAELO,oBAFK,EAGLC,uBAHK,EAILC,WAJK,EAK6B;EAClC,MAAM3C,MAAM,GAAGkC,aAAa,CAACU,IAAd,CAAmBrB,EAAlC;EACA,MAAMsB,QAAQ,GAAG,IAAAC,kBAAA,EAAQ9C,MAAR,CAAjB;EACA,MAAM+C,eAAe,GAAI,OAAzB;;EAEA,IAAI,CAACF,QAAL,EAAe;IACb,IAAIF,WAAJ,EAAiB;MACfN,iBAAA,CAASC,KAAT,CAAe;QACbf,EAAE,EAAEwB,eADS;QAEbzB,OAAO,EAAE;UACP0B,UAAU,EAAEd,aAAa,CAACc,UADnB;UAEPhD;QAFO;MAFI,CAAf;IAOD,CARD,MAQO;MACLyC,oBAAoB,CAACQ,GAArB,CAAyBF,eAAzB;IACD;;IAED,OAAO,IAAP;EACD,CAnBiC,CAqBlC;;;EACA,MAAM;IAAElB,IAAI,EAAEqB,gBAAR;IAA0BpC;EAA1B,IAA0C,MAAMf,mBAAmB,CAAC;IACxEC,MADwE;IAExE;IACAC,IAAI,EAAE4C,QAAF,aAAEA,QAAF,uBAAEA,QAAQ,CAAE5C;EAHwD,CAAD,CAAzE;EAMA,MAAMkD,kCAAkC,GAAG;IACzCjB,aADyC;IAEzCzB,QAAQ,EAAEyC,gBAAgB,CAAChC,IAFc;IAGzCJ,WAHyC;IAIzCqB,OAAO,EAAEQ;EAJgC,CAA3C;;EAOA,IAAIA,WAAJ,EAAiB;IACfV,oCAAoC,CAACkB,kCAAD,CAApC;EACD,CAFD,MAEO;IACL,MAAM;MAAEf;IAAF,IAAYH,oCAAoC,CACpDkB,kCADoD,CAAtD;;IAIA,IAAIf,KAAK,KAAM,SAAf,EAAyB;MACvBK,oBAAoB,CAACQ,GAArB,CAAyBb,KAAzB;IACD;EACF;;EAED,MAAMgB,aAA+B,GAAG;IACtCR,IAAI,EAAEV,aAAa,CAACU,IADkB;IAEtCf,IAAI,EAAEqB,gBAFgC;IAGtCpC;EAHsC,CAAxC;;EAMA,MAAMuC,mBAAmB,GAAGlD,YAAA,CAAMC,QAAN,GAAiBkD,OAAjB,CAAyBC,SAArD;;EAEA,IAAIC,YAAY,GAAGtB,aAAa,CAACuB,UAAjC;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EACE,IAAI9D,OAAO,CAAC+D,QAAR,KAAsB,OAA1B,EAAkC;IAChCF,YAAY,GAAGA,YAAY,CAACG,OAAb,CAAqB,yBAArB,EAAiD,GAAjD,CAAf;EACD,CAzEiC,CA2ElC;;;EACA,MAAMC,gBAAgB,GAAG1C,aAAA,CAAK2C,IAAL,CACvBR,mBADuB,EAEtB,QAFsB,EAGtB,kBAHsB,EAIvBnB,aAAa,CAACc,UAJS,EAKtB,GAAEQ,YAAa,OALO,CAAzB;;EAQA,MAAMM,eAAe,GAAG5C,aAAA,CAAK6C,OAAL,CAAaH,gBAAb,CAAxB;;EAEA,MAAMI,gBAAA,CAAGC,SAAH,CAAaH,eAAb,CAAN;EACA,MAAME,gBAAA,CAAGE,SAAH,CAAaN,gBAAb,EAA+BR,aAA/B,CAAN;;EAEA,IAAIT,WAAJ,EAAiB;IACfN,iBAAA,CAAS8B,IAAT,CACG,UAASjC,aAAa,CAACc,UAAW,mCAAkCQ,YAAa,EADpF;EAGD;;EAED,IAAIN,gBAAgB,CAAChC,IAArB,EAA2B;IACzBwB,uBAAuB,CAAC0B,GAAxB,CAA4BlB,gBAAgB,CAAChC,IAA7C,EAAmDsC,YAAnD;EACD;;EAED,OAAOJ,aAAP;AACD;;AAED,SAASiB,0CAAT,CAAoDC,CAApD,EAAuDC,CAAvD,EAAkE;EAChE;AACF;AACA;AACA;AACA;EACE,IAAI,CAACD,CAAC,CAACE,YAAH,IAAmB,CAACD,CAAC,CAACC,YAA1B,EAAwC;IACtC,OAAO,CAAP;EACD;;EAED,IAAI,CAACF,CAAC,CAACE,YAAP,EAAqB;IACnB,OAAO,CAAP;EACD;;EAED,IAAI,CAACD,CAAC,CAACC,YAAP,EAAqB;IACnB,OAAO,CAAC,CAAR;EACD;;EAED,OAAOC,IAAI,CAACC,KAAL,CAAWJ,CAAC,CAACE,YAAb,IAA6BC,IAAI,CAACC,KAAL,CAAWH,CAAC,CAACC,YAAb,CAApC;AACD;AAED;AACA;AACA;AACA;AACA;;;AACO,eAAeG,oBAAf,GAGG;EACR,MAAMhC,WAAW,GACfhD,OAAO,CAACC,GAAR,CAAYgF,gBAAZ,KAAkC,SAAlC,IACAjF,OAAO,CAACC,GAAR,CAAYiF,qBAAZ,KAAuC,MAFzC;EAIA,MAAMC,SAAS,GAAGL,IAAI,CAACM,GAAL,EAAlB;;EACA,IAAI;IAAEC;EAAF,IAAoB7E,YAAA,CAAMC,QAAN,EAAxB;;EAEA,MAAM6E,cAAc,GAAGD,aAAa,CAACE,MAArC;;EAEA,IAAID,cAAc,KAAK,CAAvB,EAA0B;IACxB,OAAO,IAAP;EACD;;EAED,IAAIE,uBAAuB,GAAG,CAA9B;EACA,IAAIC,oBAAoB,GAAG,CAA3B;EACA,MAAM1C,uBAA4C,GAAG,IAAI2C,GAAJ,EAArD;EACA,MAAM5C,oBAAiC,GAAG,IAAI6C,GAAJ,EAA1C;;EAEA,eAAeC,uBAAf,CACEC,QADF,EAEEC,EAFF,EAGiB;IACf,MAAMC,iBAAiB,GAAG,MAAMlD,mBAAmB,CACjDgD,QADiD,EAEjD/C,oBAFiD,EAGjDC,uBAHiD,EAIjDC,WAJiD,CAAnD;;IAOA,IAAI+C,iBAAJ,EAAuB;MACrBP,uBAAuB;IACxB,CAFD,MAEO;MACLC,oBAAoB;IACrB,CAZc,CAcf;IACA;;;IACAO,YAAY,CAAC,MAAMF,EAAE,CAAC,IAAD,EAAO,IAAP,CAAT,CAAZ;IACA;EACD;;EAED,MAAMG,wBAAwB,GAAG,IAAAC,cAAA,EAAMN,uBAAN,EAA+B,EAA/B,CAAjC;;EAEA,IAAIN,cAAc,GAAGpF,wBAArB,EAA+C;IAC7CmF,aAAa,GAAG,CAAC,GAAGA,aAAJ,CAAhB;IACAA,aAAa,CAACc,IAAd,CAAmBzB,0CAAnB;IACAW,aAAa,GAAGA,aAAa,CAACe,KAAd,CAAoB,CAApB,EAAuBlG,wBAAvB,CAAhB;EACD;;EAED,KAAK,MAAM2F,QAAX,IAAuBR,aAAvB,EAAsC;IACpCY,wBAAwB,CAACI,IAAzB,CAA8BR,QAA9B,EAAwC,MAAM,CAAE,CAAhD;EACD;;EAED,IAAI,CAACI,wBAAwB,CAACK,IAAzB,EAAL,EAAsC;IACpC,MAAM,IAAIC,OAAJ,CAAYC,OAAO,IAAI;MAC3BP,wBAAwB,CAACQ,KAAzB,GAAiCD,OAAjC;IACD,CAFK,CAAN;EAGD;;EAED,MAAME,SAAS,GAAInB,MAAD,IAChBA,MAAM,GAAG,CAAT,IAAcA,MAAM,KAAK,CAAzB,GAA8B,GAA9B,GAAoC,EADtC;;EAGA,MAAMoB,OAAO,GAAG7B,IAAI,CAACM,GAAL,EAAhB;;EAEA1C,iBAAA,CAAS8B,IAAT,CACG,aAAYgB,uBAAwB,2BAA0BkB,SAAS,CACtElB,uBADsE,CAEtE,OAAMmB,OAAO,GAAGxB,SAAU,QAC1BM,oBAAoB,GAAG,CAAvB,GACK,KAAIA,oBAAqB,YAAWiB,SAAS,CAC5CjB,oBAD4C,CAE5C,yBAHN,GAIK,EACN,EATH;;EAYA/C,iBAAA,CAAS8B,IAAT,CACE,CAAC,CAACxB,WAAD,IAAgBF,oBAAoB,CAAC8D,IAArB,GAA4B,CAA5C,GACI,kDAAiD,CAChD,GAAG9D,oBAD6C,EAEhDoB,IAFgD,CAE1C,IAF0C,CAErC,KAHhB,GAII,EAJL,IAKG,uJANL,EA7EQ,CAsFR;;;EACA1D,YAAA,CAAMqG,QAAN,CAAeC,wBAAA,CAAgBC,mBAAhB,EAAf;;EACA,OAAOhE,uBAAP;AACD"}