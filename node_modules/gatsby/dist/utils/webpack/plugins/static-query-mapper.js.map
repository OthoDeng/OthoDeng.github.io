{"version":3,"file":"static-query-mapper.js","names":["doesModuleMatchResourcePath","resourcePath","webpackModule","ConcatenatedModule","resource","modules","some","innerModule","getRealPath","cache","componentPath","has","set","path","resolve","get","getWebpackModulesByResourcePaths","staticQueries","components","realPathCache","Map","webpackModulesByStaticQueryId","webpackModulesByComponentId","forEach","id","staticQuery","staticQueryComponentPath","component","componentComponentPath","getChunkGroupsDerivedFromEntrypoint","chunkGroup","entrypoint","hasParent","chunkGroups","parentChunkGroup","getParents","newChunkGroup","concat","StaticQueryMapper","constructor","store","name","apply","compiler","staticQueryComponents","getState","hooks","done","tap","stats","compilation","parentCompilation","chunkGraph","staticQueriesByChunkGroup","chunkGroupsWithPageComponents","Set","chunkGroupsByComponentPath","appEntryPoint","entrypoints","staticQueryId","chunkGroupsDerivedFromEntrypoints","chunk","getModuleChunksIterable","groupsIterable","push","staticQueryHashes","hash","generateComponentChunkName","add","globalStaticQueries","allStaticQueries","Array","from","sort","staticQueriesByTemplate","dispatch","type","payload","pages","hasErrors","watchMode","enqueueFlush"],"sources":["../../../../src/utils/webpack/plugins/static-query-mapper.ts"],"sourcesContent":["import path from \"path\"\nimport { Store } from \"redux\"\nimport { Compiler, Module, NormalModule, Compilation } from \"webpack\"\nimport ConcatenatedModule from \"webpack/lib/optimize/ConcatenatedModule\"\nimport { isEqual } from \"lodash\"\nimport { generateComponentChunkName } from \"../../js-chunk-names\"\nimport { enqueueFlush } from \"../../page-data\"\nimport type {\n  IGatsbyState,\n  IGatsbyPageComponent,\n  IGatsbyStaticQueryComponents,\n} from \"../../../redux/types\"\n\ntype ChunkGroup = Compilation[\"chunkGroups\"][0]\ntype EntryPoint = Compilation[\"asyncEntrypoints\"][0]\n\n/**\n * Checks if a module matches a resourcePath\n */\nfunction doesModuleMatchResourcePath(\n  resourcePath: string,\n  webpackModule: Module | NormalModule | ConcatenatedModule\n): boolean {\n  if (!(webpackModule instanceof ConcatenatedModule)) {\n    return (webpackModule as NormalModule).resource === resourcePath\n  }\n\n  // ConcatenatedModule is a collection of modules so we have to go deeper to actually get it\n  return webpackModule.modules.some(\n    innerModule => (innerModule as NormalModule).resource === resourcePath\n  )\n}\n\n/**\n * A helper to set/get path resolving\n */\nfunction getRealPath(\n  cache: Map<string, string>,\n  componentPath: string\n): string {\n  if (!cache.has(componentPath)) {\n    cache.set(componentPath, path.resolve(componentPath))\n  }\n\n  return cache.get(componentPath) as string\n}\n\n/**\n * Grab the actual webpackModule from the resourcePath\n * We return staticQueries and componentPaths cause that's what we care about\n */\nfunction getWebpackModulesByResourcePaths(\n  modules: Set<Module>,\n  staticQueries: IGatsbyState[\"staticQueryComponents\"],\n  components: IGatsbyState[\"components\"]\n): {\n  webpackModulesByStaticQueryId: Map<string, Module>\n  webpackModulesByComponentId: Map<string, Module>\n} {\n  const realPathCache = new Map<string, string>()\n  const webpackModulesByStaticQueryId = new Map<string, Module>()\n  const webpackModulesByComponentId = new Map<string, Module>()\n\n  modules.forEach(webpackModule => {\n    for (const [id, staticQuery] of staticQueries) {\n      const staticQueryComponentPath = getRealPath(\n        realPathCache,\n        staticQuery.componentPath\n      )\n\n      if (\n        !doesModuleMatchResourcePath(staticQueryComponentPath, webpackModule)\n      ) {\n        continue\n      }\n\n      webpackModulesByStaticQueryId.set(id, webpackModule)\n    }\n\n    for (const [id, component] of components) {\n      const componentComponentPath = getRealPath(\n        realPathCache,\n        component.componentPath\n      )\n      if (!doesModuleMatchResourcePath(componentComponentPath, webpackModule)) {\n        continue\n      }\n\n      webpackModulesByComponentId.set(id, webpackModule)\n    }\n  })\n\n  return { webpackModulesByStaticQueryId, webpackModulesByComponentId }\n}\n\n/**\n * Chunks can be async so the group might not represent a pageComponent group\n * We'll need to search for it.\n */\nfunction getChunkGroupsDerivedFromEntrypoint(\n  chunkGroup: ChunkGroup,\n  entrypoint: EntryPoint\n): Array<ChunkGroup> {\n  // when it's imported by any globals or async-requires we know we have the correct chunkgroups.\n  // Async modules won't have hasParent listed\n  if (chunkGroup.hasParent(entrypoint)) {\n    return [chunkGroup]\n  }\n\n  let chunkGroups: Array<ChunkGroup> = []\n  for (const parentChunkGroup of chunkGroup.getParents()) {\n    const newChunkGroup = getChunkGroupsDerivedFromEntrypoint(\n      parentChunkGroup,\n      entrypoint\n    )\n    chunkGroups = chunkGroups.concat(newChunkGroup)\n  }\n\n  return chunkGroups\n}\n\nexport class StaticQueryMapper {\n  private store: Store<IGatsbyState>\n  private name: string\n\n  constructor(store) {\n    this.store = store\n    this.name = `StaticQueryMapper`\n  }\n\n  apply(compiler: Compiler): void {\n    const { components, staticQueryComponents } = this.store.getState()\n\n    compiler.hooks.done.tap(this.name, stats => {\n      const compilation = stats.compilation\n      // We only care about the main compilation\n      // Chunkgraph should always be available when it's done but you know typescript.\n      if (compilation.compiler.parentCompilation || !compilation.chunkGraph) {\n        return\n      }\n\n      const staticQueriesByChunkGroup = new Map<ChunkGroup, Array<string>>()\n      const chunkGroupsWithPageComponents = new Set<ChunkGroup>()\n      const chunkGroupsByComponentPath = new Map<\n        IGatsbyPageComponent[\"componentPath\"],\n        ChunkGroup\n      >()\n\n      const { webpackModulesByStaticQueryId, webpackModulesByComponentId } =\n        getWebpackModulesByResourcePaths(\n          compilation.modules,\n          staticQueryComponents,\n          components\n        )\n\n      const appEntryPoint = (\n        compilation.entrypoints.has(`app`)\n          ? compilation.entrypoints.get(`app`)\n          : compilation.entrypoints.get(`commons`)\n      ) as EntryPoint\n\n      // group hashes by chunkGroup for ease of use\n      for (const [\n        staticQueryId,\n        webpackModule,\n      ] of webpackModulesByStaticQueryId) {\n        let chunkGroupsDerivedFromEntrypoints: Array<ChunkGroup> = []\n        for (const chunk of compilation.chunkGraph.getModuleChunksIterable(\n          webpackModule\n        )) {\n          for (const chunkGroup of chunk.groupsIterable) {\n            if (chunkGroup === appEntryPoint) {\n              chunkGroupsDerivedFromEntrypoints.push(chunkGroup)\n            } else {\n              chunkGroupsDerivedFromEntrypoints =\n                chunkGroupsDerivedFromEntrypoints.concat(\n                  getChunkGroupsDerivedFromEntrypoint(chunkGroup, appEntryPoint)\n                )\n            }\n          }\n        }\n\n        // loop over all component chunkGroups or global ones\n        chunkGroupsDerivedFromEntrypoints.forEach(chunkGroup => {\n          const staticQueryHashes =\n            staticQueriesByChunkGroup.get(chunkGroup) ?? []\n\n          staticQueryHashes.push(\n            (\n              staticQueryComponents.get(\n                staticQueryId\n              ) as IGatsbyStaticQueryComponents\n            ).hash\n          )\n\n          staticQueriesByChunkGroup.set(chunkGroup, staticQueryHashes)\n        })\n      }\n\n      // group chunkGroups by componentPaths for ease of use\n      for (const [\n        componentPath,\n        webpackModule,\n      ] of webpackModulesByComponentId) {\n        for (const chunk of compilation.chunkGraph.getModuleChunksIterable(\n          webpackModule\n        )) {\n          for (const chunkGroup of chunk.groupsIterable) {\n            // When it's a direct import from app entrypoint (async-requires) we know we have the correct chunkGroup\n            if (chunkGroup.name === generateComponentChunkName(componentPath)) {\n              chunkGroupsWithPageComponents.add(chunkGroup)\n              chunkGroupsByComponentPath.set(componentPath, chunkGroup)\n            }\n          }\n        }\n      }\n\n      let globalStaticQueries: Array<string> = []\n      for (const [chunkGroup, staticQueryHashes] of staticQueriesByChunkGroup) {\n        // When a chunkgroup is not part of a pageComponent we know it's part of a global group.\n        if (!chunkGroupsWithPageComponents.has(chunkGroup)) {\n          globalStaticQueries = globalStaticQueries.concat(staticQueryHashes)\n        }\n      }\n\n      components.forEach(component => {\n        const allStaticQueries = new Set(globalStaticQueries)\n        if (chunkGroupsByComponentPath.has(component.componentPath)) {\n          const chunkGroup = chunkGroupsByComponentPath.get(\n            component.componentPath\n          )\n          if (chunkGroup && staticQueriesByChunkGroup.has(chunkGroup)) {\n            ;(\n              staticQueriesByChunkGroup.get(chunkGroup) as Array<string>\n            ).forEach(staticQuery => {\n              allStaticQueries.add(staticQuery)\n            })\n          }\n        }\n\n        // modules, chunks, chunkgroups can all have not-deterministic orders so\n        // just sort array of static queries we produced to ensure final result is deterministic\n        const staticQueryHashes = Array.from(allStaticQueries).sort()\n\n        if (\n          !isEqual(\n            this.store\n              .getState()\n              .staticQueriesByTemplate.get(component.componentPath),\n            staticQueryHashes\n          )\n        ) {\n          this.store.dispatch({\n            type: `ADD_PENDING_TEMPLATE_DATA_WRITE`,\n            payload: {\n              componentPath: component.componentPath,\n              pages: component.pages,\n            },\n          })\n\n          this.store.dispatch({\n            type: `SET_STATIC_QUERIES_BY_TEMPLATE`,\n            payload: {\n              componentPath: component.componentPath,\n              staticQueryHashes,\n            },\n          })\n        }\n      })\n\n      // In dev mode we want to write page-data when compilation succeeds\n      if (!stats.hasErrors() && compiler.watchMode) {\n        enqueueFlush()\n      }\n    })\n  }\n}\n"],"mappings":"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"}