{"version":3,"file":"requires-writer.js","names":["paramRe","SEGMENT_POINTS","STATIC_POINTS","DYNAMIC_POINTS","SPLAT_PENALTY","ROOT_POINTS","isRootSegment","segment","isDynamic","test","isSplat","hasContentFilePath","componentPath","includes","segmentize","uri","replace","split","rankRoute","path","reduce","score","lastHash","resetLastHash","pickComponentFields","page","componentChunkName","getComponents","pages","slices","values","c","getMatchPaths","createMatchPathEntry","index","matchPath","undefined","reporter","panic","matchPathPages","forEach","getPageMode","push","length","newMatches","isInsideMatchPath","find","pageWithMatchPath","match","sort","a","b","order","localeCompare","map","createHash","matchPaths","components","cleanedSSRVisitedPageComponents","crypto","update","JSON","stringify","digest","writeAll","state","program","process","env","GATSBY_EXPERIMENTAL_DEV_SSR","ssrVisitedPageComponents","visitedPages","get","filter","some","s","newHash","lazySyncRequires","joinPath","join","writeModule","devSSRWillInvalidate","syncRequires","asyncRequires","gatsby_executing_command","GATSBY_PARTIAL_HYDRATION","relativeComponentPath","relative","getAbsolutePathForVirtualModule","rqPrefix","slash","writeAndMove","virtualFilePath","file","data","destination","directory","tmp","Date","now","fs","writeFile","then","move","overwrite","Promise","all","debouncedWriteAll","activity","activityTimer","id","start","store","getState","end","leading","listenerStarted","startListener","emitter","on","pendingActivity"],"sources":["../../src/bootstrap/requires-writer.ts"],"sourcesContent":["import _ from \"lodash\"\nimport path from \"path\"\nimport fs from \"fs-extra\"\nimport crypto from \"crypto\"\nimport { slash } from \"gatsby-core-utils\"\nimport reporter from \"gatsby-cli/lib/reporter\"\nimport { match } from \"@gatsbyjs/reach-router\"\nimport { joinPath } from \"gatsby-core-utils\"\nimport { store, emitter } from \"../redux/\"\nimport { IGatsbyState, IGatsbyPage, IGatsbySlice } from \"../redux/types\"\nimport {\n  writeModule,\n  getAbsolutePathForVirtualModule,\n} from \"../utils/gatsby-webpack-virtual-modules\"\nimport { getPageMode } from \"../utils/page-mode\"\nimport { devSSRWillInvalidate } from \"../commands/build-html\"\n\ninterface IGatsbyPageComponent {\n  componentPath: string\n  componentChunkName: string\n}\n\ninterface IGatsbyPageMatchPath {\n  path: string\n  matchPath: string | undefined\n}\n\n// path ranking algorithm copied (with small adjustments) from `@reach/router` (internal util, not exported from the package)\n// https://github.com/reach/router/blob/28a79e7fc3a3487cb3304210dc3501efb8a50eba/src/lib/utils.js#L216-L254\nconst paramRe = /^:(.+)/\n\nconst SEGMENT_POINTS = 4\nconst STATIC_POINTS = 3\nconst DYNAMIC_POINTS = 2\nconst SPLAT_PENALTY = 1\nconst ROOT_POINTS = 1\n\nconst isRootSegment = (segment: string): boolean => segment === ``\nconst isDynamic = (segment: string): boolean => paramRe.test(segment)\nconst isSplat = (segment: string): boolean => segment === `*`\nconst hasContentFilePath = (componentPath: string): boolean =>\n  componentPath.includes(`?__contentFilePath=`)\n\nconst segmentize = (uri: string): Array<string> =>\n  uri\n    // strip starting/ending slashes\n    .replace(/(^\\/+|\\/+$)/g, ``)\n    .split(`/`)\n\nconst rankRoute = (path: string): number =>\n  segmentize(path).reduce((score, segment) => {\n    score += SEGMENT_POINTS\n    if (isRootSegment(segment)) score += ROOT_POINTS\n    else if (isDynamic(segment)) score += DYNAMIC_POINTS\n    else if (isSplat(segment)) score -= SEGMENT_POINTS + SPLAT_PENALTY\n    else score += STATIC_POINTS\n    return score\n  }, 0)\n// end of copied `@reach/router` internals\n\nlet lastHash: string | null = null\n\nexport const resetLastHash = (): void => {\n  lastHash = null\n}\n\ntype IBareComponentData = Pick<\n  IGatsbyPageComponent,\n  `componentPath` | `componentChunkName`\n>\nconst pickComponentFields = (\n  page: IGatsbyPage | IGatsbySlice\n): IBareComponentData => {\n  return {\n    componentPath: page.componentPath,\n    componentChunkName: page.componentChunkName,\n  }\n}\n\nexport const getComponents = (\n  pages: Array<IGatsbyPage>,\n  slices: IGatsbyState[\"slices\"]\n): Array<IGatsbyPageComponent> =>\n  _.orderBy(\n    _.uniqBy(\n      _.map([...pages, ...slices.values()], pickComponentFields),\n      c => c.componentChunkName\n    ),\n    c => c.componentChunkName\n  )\n\n/**\n * Get all dynamic routes and sort them by most specific at the top\n * code is based on @reach/router match utility (https://github.com/reach/router/blob/152aff2352bc62cefc932e1b536de9efde6b64a5/src/lib/utils.js#L224-L254)\n */\nconst getMatchPaths = (\n  pages: Array<IGatsbyPage>\n): Array<IGatsbyPageMatchPath> => {\n  interface IMatchPathEntry extends IGatsbyPage {\n    index: number\n    score: number\n    matchPath: string\n  }\n\n  const createMatchPathEntry = (\n    page: IGatsbyPage,\n    index: number\n  ): IMatchPathEntry => {\n    const { matchPath } = page\n\n    if (matchPath === undefined) {\n      return reporter.panic(\n        `Error: matchPath property is undefined for page ${page.path}, should be a string`\n      ) as never\n    }\n\n    return {\n      ...page,\n      matchPath,\n      index,\n      score: rankRoute(matchPath),\n    }\n  }\n\n  const matchPathPages: Array<IMatchPathEntry> = []\n\n  pages.forEach((page: IGatsbyPage, index: number): void => {\n    if (page.matchPath && getPageMode(page) === `SSG`) {\n      matchPathPages.push(createMatchPathEntry(page, index))\n    }\n  })\n\n  // Pages can live in matchPaths, to keep them working without doing another network request\n  // we save them in matchPath. We use `@reach/router` path ranking to score paths/matchPaths\n  // and sort them so more specific paths are before less specific paths.\n  // More info in https://github.com/gatsbyjs/gatsby/issues/16097\n  // small speedup: don't bother traversing when no matchPaths found.\n  if (matchPathPages.length) {\n    const newMatches: Array<IMatchPathEntry> = []\n\n    pages.forEach((page: IGatsbyPage, index: number): void => {\n      const isInsideMatchPath = !!matchPathPages.find(\n        pageWithMatchPath =>\n          !page.matchPath && match(pageWithMatchPath.matchPath, page.path)\n      )\n\n      if (isInsideMatchPath) {\n        newMatches.push(\n          createMatchPathEntry(\n            {\n              ...page,\n              matchPath: page.path,\n            },\n            index\n          )\n        )\n      }\n    })\n    // Add afterwards because the new matches are not relevant for the existing search\n    matchPathPages.push(...newMatches)\n  }\n\n  return matchPathPages\n    .sort((a, b) => {\n      // The higher the score, the higher the specificity of our matchPath\n      const order = b.score - a.score\n      if (order !== 0) {\n        return order\n      }\n\n      // if specificity is the same we do lexigraphic comparison of path to ensure\n      // deterministic order regardless of order pages where created\n      return a.matchPath.localeCompare(b.matchPath)\n    })\n    .map(({ path, matchPath }) => {\n      return { path, matchPath }\n    })\n}\n\nconst createHash = (\n  matchPaths: Array<IGatsbyPageMatchPath>,\n  components: Array<IGatsbyPageComponent>,\n  cleanedSSRVisitedPageComponents: Array<IGatsbyPageComponent>\n): string =>\n  crypto\n    .createHash(`md5`)\n    .update(\n      JSON.stringify({\n        matchPaths,\n        components,\n        cleanedSSRVisitedPageComponents,\n      })\n    )\n    .digest(`hex`)\n\n// Write out pages information.\nexport const writeAll = async (state: IGatsbyState): Promise<boolean> => {\n  const { program, slices } = state\n  const pages = [...state.pages.values()]\n  const matchPaths = getMatchPaths(pages)\n  const components = getComponents(pages, slices)\n  let cleanedSSRVisitedPageComponents: Array<IGatsbyPageComponent> = []\n\n  if (process.env.GATSBY_EXPERIMENTAL_DEV_SSR) {\n    const ssrVisitedPageComponents = [\n      ...(state.visitedPages.get(`server`)?.values() || []),\n    ]\n\n    // Remove any page components that no longer exist.\n    cleanedSSRVisitedPageComponents = components.filter(c =>\n      ssrVisitedPageComponents.some(s => s === c.componentChunkName)\n    )\n  }\n\n  const newHash = createHash(\n    matchPaths,\n    components,\n    cleanedSSRVisitedPageComponents\n  )\n\n  if (newHash === lastHash) {\n    // Nothing changed. No need to rewrite files\n    return false\n  }\n\n  lastHash = newHash\n\n  if (process.env.GATSBY_EXPERIMENTAL_DEV_SSR) {\n    // Create file with sync requires of visited page components files.\n\n    const lazySyncRequires = `exports.ssrComponents = {\\n${cleanedSSRVisitedPageComponents\n      .map(\n        (c: IGatsbyPageComponent): string =>\n          `  \"${c.componentChunkName}\": require(\"${joinPath(c.componentPath)}\")`\n      )\n      .join(`,\\n`)}\n  }\\n\\n`\n\n    writeModule(`$virtual/ssr-sync-requires`, lazySyncRequires)\n    // if this is executed, webpack should mark it as invalid, but sometimes there is some timing race\n    // so we also explicitly set flag here as well\n    devSSRWillInvalidate()\n  }\n\n  // Create file with sync requires of components/json files.\n  let syncRequires = `\n// prefer default export if available\nconst preferDefault = m => (m && m.default) || m\n\\n\\n`\n  syncRequires += `exports.components = {\\n${components\n    .map(\n      (c: IGatsbyPageComponent): string =>\n        `  \"${c.componentChunkName}\": preferDefault(require(\"${joinPath(\n          c.componentPath\n        )}\"))`\n    )\n    .join(`,\\n`)}\n}\\n\\n`\n\n  // Create file with async requires of components/json files.\n  let asyncRequires = ``\n\n  if (\n    process.env.gatsby_executing_command === `develop` ||\n    (_CFLAGS_.GATSBY_MAJOR === `5` && process.env.GATSBY_PARTIAL_HYDRATION)\n  ) {\n    asyncRequires = `exports.components = {\\n${components\n      .map((c: IGatsbyPageComponent): string => {\n        // we need a relative import path to keep contenthash the same if directory changes\n        const relativeComponentPath = path.relative(\n          getAbsolutePathForVirtualModule(`$virtual`),\n          c.componentPath\n        )\n\n        const rqPrefix = hasContentFilePath(relativeComponentPath) ? `&` : `?`\n\n        return `  \"${c.componentChunkName}\": () => import(\"${slash(\n          `./${relativeComponentPath}`\n        )}${rqPrefix}export=default\" /* webpackChunkName: \"${\n          c.componentChunkName\n        }\" */)`\n      })\n      .join(`,\\n`)}\n}\\n\\n\n\nexports.head = {\\n${components\n      .map((c: IGatsbyPageComponent): string => {\n        // we need a relative import path to keep contenthash the same if directory changes\n        const relativeComponentPath = path.relative(\n          getAbsolutePathForVirtualModule(`$virtual`),\n          c.componentPath\n        )\n\n        const rqPrefix = hasContentFilePath(relativeComponentPath) ? `&` : `?`\n\n        return `  \"${c.componentChunkName}\": () => import(\"${slash(\n          `./${relativeComponentPath}`\n        )}${rqPrefix}export=head\" /* webpackChunkName: \"${\n          c.componentChunkName\n        }head\" */)`\n      })\n      .join(`,\\n`)}\n}\\n\\n`\n  } else {\n    asyncRequires = `exports.components = {\\n${components\n      .map((c: IGatsbyPageComponent): string => {\n        // we need a relative import path to keep contenthash the same if directory changes\n        const relativeComponentPath = path.relative(\n          getAbsolutePathForVirtualModule(`$virtual`),\n          c.componentPath\n        )\n        return `  \"${c.componentChunkName}\": () => import(\"${slash(\n          `./${relativeComponentPath}`\n        )}\" /* webpackChunkName: \"${c.componentChunkName}\" */)`\n      })\n      .join(`,\\n`)}\n}\\n\\n`\n  }\n\n  const writeAndMove = (\n    virtualFilePath: string,\n    file: string,\n    data: string\n  ): Promise<void> => {\n    writeModule(virtualFilePath, data)\n\n    // files in .cache are not used anymore as part of webpack builds, but\n    // still can be used by other tools (for example `gatsby serve` reads\n    // `match-paths.json` to setup routing)\n    const destination = joinPath(program.directory, `.cache`, file)\n    const tmp = `${destination}.${Date.now()}`\n    return fs\n      .writeFile(tmp, data)\n      .then(() => fs.move(tmp, destination, { overwrite: true }))\n  }\n\n  await Promise.all([\n    writeAndMove(`$virtual/sync-requires.js`, `sync-requires.js`, syncRequires),\n    writeAndMove(\n      `$virtual/async-requires.js`,\n      `async-requires.js`,\n      asyncRequires\n    ),\n    writeAndMove(\n      `$virtual/match-paths.json`,\n      `match-paths.json`,\n      JSON.stringify(matchPaths, null, 4)\n    ),\n  ])\n\n  return true\n}\n\nconst debouncedWriteAll = _.debounce(\n  async (): Promise<void> => {\n    const activity = reporter.activityTimer(`write out requires`, {\n      id: `requires-writer`,\n    })\n    activity.start()\n    await writeAll(store.getState())\n    activity.end()\n  },\n  500,\n  {\n    // using \"leading\" can cause double `writeAll` call - particularly\n    // when refreshing data using `/__refresh` hook.\n    leading: false,\n  }\n)\n\n/**\n * Start listening to CREATE/DELETE_PAGE events so we can rewrite\n * files as required\n */\nlet listenerStarted = false\nexport const startListener = (): void => {\n  // Only start the listener once.\n  if (listenerStarted) {\n    return\n  }\n  listenerStarted = true\n\n  if (process.env.GATSBY_EXPERIMENTAL_DEV_SSR) {\n    /**\n     * Start listening to CREATE_SERVER_VISITED_PAGE events so we can rewrite\n     * files as required\n     */\n    emitter.on(`CREATE_SERVER_VISITED_PAGE`, async (): Promise<void> => {\n      // this event only happen on new additions\n      devSSRWillInvalidate()\n      reporter.pendingActivity({ id: `requires-writer` })\n      debouncedWriteAll()\n    })\n  }\n\n  emitter.on(`CREATE_PAGE`, (): void => {\n    reporter.pendingActivity({ id: `requires-writer` })\n    debouncedWriteAll()\n  })\n\n  emitter.on(`CREATE_PAGE_END`, (): void => {\n    reporter.pendingActivity({ id: `requires-writer` })\n    debouncedWriteAll()\n  })\n\n  emitter.on(`DELETE_PAGE`, (): void => {\n    reporter.pendingActivity({ id: `requires-writer` })\n    debouncedWriteAll()\n  })\n\n  emitter.on(`DELETE_PAGE_BY_PATH`, (): void => {\n    reporter.pendingActivity({ id: `requires-writer` })\n    debouncedWriteAll()\n  })\n}\n"],"mappings":"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"}