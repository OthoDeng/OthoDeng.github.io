"use strict";(self.webpackChunkottoqwq_github_io=self.webpackChunkottoqwq_github_io||[]).push([[31],{1987:function(e,n,t){t.r(n);var r=t(1151),l=t(7294);const a=function(e){let{children:n}=e;const t=Object.assign({main:"main"},(0,r.ah)());return l.createElement(t.main,{align:"left",style:{color:"#EF9A9A"}},n)};function o(e){const n=Object.assign({h1:"h1",h2:"h2",h3:"h3",p:"p",pre:"pre",code:"code",a:"a",strong:"strong",hr:"hr"},(0,r.ah)(),e.components);return l.createElement(l.Fragment,null,l.createElement("title",null,"Gentoo-on-rpi4"),"\n",l.createElement(n.h1,null,"Gentoo-on-rpi4"),"\n",l.createElement(n.h2,null,"基础安装"),"\n",l.createElement(n.h3,null,"SD卡的准备"),"\n",l.createElement(n.p,null,"首先准备SD card 一张。在SD 卡上至少创建两个分区。\nSD的/ boot分区应该是FAT32。根（/分区可以是任何首选的 Linux文件系统，但是由于 SD 卡是基于闪存的介质，使用F2FS有很多好处。\n大致情况可以如下："),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-bash"},"\tDisk /dev/sdb: 16.6 GB, 16574840832 bytes\n\t255 heads, 63 sectors/track, 2015 cylinders, total 32372736 sectors\n\tUnits = sectors of 1 * 512 = 512 bytes\n\tSector size (logical/physical): 512 bytes / 512 bytes\n\tI/O size (minimum/optimal): 512 bytes / 512 bytes\n\tDisk identifier: 0x1db42224\n\t\n\tDevice Boot      Start         End      Blocks   Id  System\n\t/dev/sdb1   *        2048      835379      416666    c  W95 FAT32 (LBA)\n\t/dev/sdb2          835380    31889024    15526822+  83  Linux\n\t/dev/sdb3        31889025    32372735      241855+   5  Extended\n\t/dev/sdb5        31889088    32372735      241824   82  Linux swap / Solaris\n")),"\n",l.createElement(n.h3,null,"发行版的选择"),"\n",l.createElement(n.p,null,"树莓派使用的是ARM架构的linux系统。对于发行版，我们可以选择Debian系下的产品（如Ubuntu的server版本，也可以选择树莓派的官方镜像）\n而我这次选择的是Gentoo Linux，因为它支持arm架构，同时支持32位，同时Gentoo Linux 支持编译整个系统，把原来官方提供的stage3 tarball里的所有组件替换成自己编译的（包括GCC编译器和所有基本系统组件），这样一来整个系统的所有程序和组件都是针对树莓派CPU架构优化编译的了，争取性能最大化。"),"\n",l.createElement(n.h3,null,"启动分区"),"\n",l.createElement(n.p,null,"正确的/boot分区的最低设置需要以下由 Raspberry Pi 基金会提供的",l.createElement(n.a,{href:"https://github.com/raspberrypi/firmware"},"专有固件文件"),"\n",l.createElement(n.code,null,"bootcode.bin"),"\n",l.createElement(n.code,null,"fixup.dat"),"\n",l.createElement(n.code,null,"start.elf"),"\n",l.createElement(n.code,null,"kernel image(s)")),"\n",l.createElement(n.p,null,l.createElement(n.code,null,"DTB (Device Tree Blob) files")),"\n",l.createElement(n.p,null,"要使用config.txt 中的gpu_mem=16设置启动树莓派，需要以下文件：\nge3-armv7a_hardfp-YYYYMMDD.tar.bz2 -C /mnt/raspberrypiroot/\nfixup_cd.dat\nstart_cd.elf"),"\n",l.createElement(n.p,null,"Pi 有两个视频驱动程序。较旧的使用固定的保留 GPU 内存空间。开源 VC4 驱动程序使用内核连续内存分配器。使用vc4驱动时设置gpu_mem=16，避免浪费RAM。\n我们可以merge一个sys-boot/raspberrypi-firmware来是它运行。"),"\n",l.createElement(n.p,null,"root #emerge --ask sys-boot/raspberrypi-firmware"),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"固件文件安装在/boot 中。在出现sys-boot/raspberrypi-firmware包之前，应将 SD 卡的引导分区挂载在/boot上。"),"\n或者我们可以选择安装预编译好的树莓派内核以及模块："),"\n",l.createElement(n.p,null,"root #emerge --ask sys-kernel/raspberrypi-image"),"\n",l.createElement(n.h3,null,"下载并解压stage3"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-shell"},"\twget http://distfiles.gentoo.org/releases/arm/autobuilds/current-stage3-armv7a_hardfp/stage3-armv7a_hardfp-YYYYMMDD.tar.bz2\n\t#国内的镜像源可能并未同步该镜像\n\ttar xpjf stage3-armv7a_hardfp-YYYYMMDD.tar.bz2 -C /mnt/raspberrypiroot/\n")),"\n",l.createElement(n.h3,null,"修改make.conf"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-shell"},'\tnano -w /mnt/raspberrypiroot/etc/portage/make.conf\n\n\n\t# Raspberry Pi 2, or Raspberry Pi 3 running in 32 bit mode:\n\tCFLAGS="-O2 -march=armv7-a -mfpu=neon-vfpv4 -mfloat-abi=hard"\n\tCXXFLAGS="${CFLAGS}"\n')),"\n",l.createElement(n.h3,null,"修改fstab"),"\n",l.createElement(n.p,null,"我们使用lsblk以及blkid命令来查找分区。\nSD卡一般被识别为/dev/mmcblk0\nge3-armv7a_hardfp-YYYYMMDD.tar.bz2 -C /mnt/raspberrypiroot/"),"\n",l.createElement(n.h3,null,"生成root密码的hash，并添加至/etc/shadow"),"\n",l.createElement(n.p,null,"root #openssl passwd -1"),"\n",l.createElement(n.h3,null,"（可选）stage4文件"),"\n",l.createElement(n.p,null,l.createElement(n.a,{href:"https://github.com/raspberrypi/noobs"},"每日NOOBS image会更新"),"\n解压时解压在/os/Gentoo"),"\n",l.createElement(n.h3,null,"Portage树"),"\n",l.createElement(n.p,null,"下载最新的 Portage 树："),"\n",l.createElement(n.p,null,"root #wget http://distfiles.gentoo.org/snapshots/portage-latest.tar.bz2"),"\n",l.createElement(n.p,null,"确保根分区上有足够的空闲 inode 块。Portage 占用大约 181K 的 inode。"),"\n",l.createElement(n.p,null,"root #df -ih | grep -E 'Mounted|mmc'"),"\n",l.createElement(n.p,null,"将 Portage 解压到 SD 卡："),"\n",l.createElement(n.p,null,"root #tar xjvpf portage-latest.tar.bz2 -C /mnt/raspberrypiroot/usr"),"\n",l.createElement(n.h3,null,"交叉编译"),"\n",l.createElement(n.p,null,"由于树莓派处理器相比现代处理器差了很多，为了加快Gentoo的安装过程，我们可以选择使用另一台机子进行编译作业。\n使用crossdev："),"\n",l.createElement(n.p,null,"root #emerge --ask sys-devel/crossdev"),"\n",l.createElement(n.p,null,"对于 64 位模式的 Raspberry ："),"\n",l.createElement(n.p,null,"root #crossdev -S -t aarch64-unknown-linux-gnu --genv 'USE=\"cxx multilib fortran -mudflap nls openmp -sanitize\"' #USE变量一定要配置！！！\nroot #cd /usr/aarch64-unknown-linux-gnu/etc/portage && rm make.profile && ln -s /usr/portage/profiles/default/linux/arm64/13.0/desktop make.profile"),"\n",l.createElement(n.p,null,"在另一主机上："),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-shell"},"gentoo_pc ~ # emerge --ask --verbose sys-devel/crossdev`\n")),"\n",l.createElement(n.p,null,"修改/etc/portage/repos.conf/crossdev.conf："),"\n",l.createElement(n.p,null,"[crossdev]"),"\n",l.createElement(n.p,null,"location = /usr/local/portage-crossdev\npriority = 10\nmasters = gentoo\nauto-sync = no"),"\n",l.createElement(n.p,null,"准备USE变量："),"\n",l.createElement(n.p,null,"gentoo_pc ~ # mkdir -pv /usr/local/portage-crossdev\ngentoo_pc ~ # crossdev --stable -t aarch64-unknown-linux-gnu -oO /usr/local/portage-crossdev"),"\n",l.createElement(n.p,null,"跑完之后，我们的交叉编译工具链已经配置好了：\n我们进入到portage："),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-shell"},"gentoo_pc ~ # cd /usr/aarch64-unknown-linux-gnu/etc/portage\n\ngentoo_pc portage # rm -f make.profile\ngentoo_pc portage # ln -s /usr/portage/profiles/default/linux/arm64/17.0/desktop make.profile\n")),"\n",l.createElement(n.p,null,"检查toolchain："),"\n",l.createElement(n.p,null,"gentoo_pc ~ # aarch64-unknown-linux-gnu-gcc --version\ngentoo_pc ~ # aarch64-unknown-linux-gnu-c++ --version\ngentoo_pc ~ # aarch64-unknown-linux-gnu-g++ --version"),"\n",l.createElement(n.p,null,"如果架构的选择没正确，我们就需要重新选择config，再source新的profile，示例如下："),"\n",l.createElement(n.p,null,"gentoo_pc ~ # gcc-config -l\n[1] aarch64-unknown-linux-gnu-5.4.0"),"\n",l.createElement(n.p,null,"[2] x86_64-pc-linux-gnu-4.9.4\n[3] x86_64-pc-linux-gnu-5.4.0 * #选择了错误的架构"),"\n",l.createElement(n.p,null,"gentoo_pc ~ # gcc-config aarch64-unknown-linux-gnu-5.4.0\ngentoo_pc ~ # source /etc/profile"),"\n",l.createElement(n.h3,null,"在chroot里编译"),"\n",l.createElement(n.p,null,"可以使用通用的 x86_64 或 i386 PC 来 chroot 到带有 Raspberry Pi 系统的现有 SD 卡。这种方法比在 Raspberry Pi 上编译要快得多。\n为此，需要静态安装app-emulation/qemu："),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-shell"},"    root #echo app-emulation/qemu static-user qemu_user_targets_aarch64 qemu_user_targets_arm >> /etc/portage/package.use/qemu #写入USE变量\n    root #emerge qemu\t\n    root #quickpkg qemu\n")),"\n",l.createElement(n.p,null,"在创建带有 ",l.createElement(n.code,null,"static-user")," USE 标志的 QEMU 之后，需要将qemu-arm可执行文件复制到 chrooting 系统中："),"\n",l.createElement(n.p,null,"root #cd /mnt/rpi\nroot #ROOT=$PWD/ emerge --usepkgonly --oneshot --nodeps qemu"),"\n",l.createElement(n.p,null,"完成后，需要在运行内核中用 ARM 可执行解释器："),"\n",l.createElement(n.p,null,"root #echo ':arm:M::\\x7fELF\\x01\\x01\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x28\\x00:\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xfe\\xff\\xff\\xff:/usr/bin/qemu-arm:' > /proc/sys/fs/binfmt_misc/register\nroot #echo ':aarch64:M::\\x7fELF\\x02\\x01\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x03\\x00\\xb7\\x00:\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xfe\\xff\\xff\\xff:/usr/bin/qemu-aarch64:' > /proc/sys/fs/binfmt_misc/register"),"\n",l.createElement(n.h3,null,"挂载文件系统"),"\n",l.createElement(n.p,null,"root #mount /dev/mmcblk0p1 /mnt/rpi/boot\nroot #mount -o bind /dev /mnt/rpi/dev\nroot #mount -o bind /proc /mnt/rpi/proc\nroot #mount -o bind /sys /mnt/rpi/sys\nroot #mount -o rw,nosuid,noexec,relatime,gid=5,mode=620,ptmxmode=000 devpts /mnt/rpi/dev/pts -t devpts"),"\n",l.createElement(n.h3,null,"复制DNS信息"),"\n",l.createElement(n.p,null,"root #cp /etc/resolv.conf /mnt/rpi/etc/"),"\n",l.createElement(n.p,null,"最后chroot进入树莓派系统："),"\n",l.createElement(n.p,null,"root #chroot /mnt/rpi"),"\n",l.createElement(n.h3,null,"编译内核"),"\n",l.createElement(n.p,null,"Linux内核是所有发行版的核心。它位于用户程序和系统硬件之间。"),"\n",l.createElement(n.p,null,"root #emerge --ask sys-kernel/raspberrypi-sources"),"\n",l.createElement(n.p,null,"同样，我们可以选择手动配置内核或者使用genkernel来自动配置并编译内核：\n这里我们选择使用genkernel来自动配置：\n修改一下配置："),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-bash"},'/etc/genkernel-rpi.conf\n        \n# install kernel manually\nINSTALL="no"\n        \n#  Set arch to arm\nARCH_OVERRIDE="arm"\n        \n# No need to mount BOOTDIR and make symlink as the kernel is\n# installed manually\nMOUNTBOOT="no"\nSYMLINK="no"\n        \n# Adjust this as needed for the machine.\nMAKEOPTS="-j3"\n        \n# For  Raspberry Pi 3 B in 32/64-bit mode\nUTILS_CROSS_COMPILE="armv7a-unknown-linux-gnueabihf-"\nKERNEL_CROSS_COMPILE="armv7a-unknown-linux-gnueabihf-"\nKERNEL_CC="armv7a-unknown-linux-gnueabihf-gcc"\nKERNEL_AS="armv7a-unknown-linux-gnueabihf-as"\nKERNEL_LD="armv7a-unknown-linux-gnueabihf-ld"\n        \n# Change this to the path of raspberrypi linux kernel sources.\n# It is possible to make this a symlink pointing to the\n# /usr/src/linux-rpi like it\'s done with a normal kernel.\n# For example: ln -s /usr/src/linux-3.6.11-raspberrypi /usr/src/linux-rpi\nDEFAULT_KERNEL_SOURCE="/usr/src/linux-rpi"\n        \n# Point this variable to the directory where the SD card is mounted.\n# Note that the location needs to be mounted manually before running genkernel.\nINSTALL_MOD_PATH="/mnt/raspberrypiroot"\n        \n# Genkernel needs access so /usr/share/genkernel (This folder contains default\n# environment variables, scripts and source tarballs that enable genkernel to\n# work).\nGK_SHARE="${GK_SHARE:-/usr/share/genkernel}"\nDISTDIR="${GK_SHARE}/distfiles"\n        \n# Genkernel also needs to have a logfile to write to. Without this present,\n# you\'ll see "ambiguous redirect" printed out many times between legitimate\n# messages.\nLOGFILE="/var/log/genkernel.log"\n')),"\n",l.createElement(n.p,null,"保存配置文件。\n挂载树莓派SD卡（假设树莓派的根分区设备是/dev/sdd3）："),"\n",l.createElement(n.p,null,"root #mount /dev/sdd3 /mnt/raspberrypiroot"),"\n",l.createElement(n.p,null,"genkernel配置："),"\n",l.createElement(n.p,null,"root #ARCH=arm genkernel --config=/etc/genkernel-rpi2.conf --kernel-config=/usr/src/linux-rpi/arch/arm/configs/bcm2709_defconfig kernel"),"\n",l.createElement(n.p,null,"保存配置/usr/local/bin/genkernel-rpi.sh:"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-bash"},"#!/bin/sh\nARCH=arm genkernel --config=/etc/genkernel-rpi2.conf --kernel-config=/usr/src/linux-rpi/arch/arm/configs/bcm2709_defconfig kernel\n\n\nroot #chmod +x /usr/local/bin/genkernel-rpi.sh\n")),"\n",l.createElement(n.p,null,"以上步骤是在完善genkernel的一些基本配置，现在我们就可以为我们的树莓派去跑genkernel命令了。"),"\n",l.createElement(n.p,null,"root #genkernel-rpi.sh"),"\n",l.createElement(n.h3,null,"安装kernel image"),"\n",l.createElement(n.p,null,"这个步骤在实操过程中是比较棘手的，对于生成在/mnt/raspberrypiroot/boot/kernel.img可能无法正确引导kernel，这时候我们可能要使用到就一些版本的固件："),"\n",l.createElement(n.p,null,"root #emerge --ask sys-boot/raspberrypi-mkimage\nroot #imagetool-uncompressed.py arch/arm/boot/Image /mnt/raspberrypiroot/boot/kernel.img"),"\n",l.createElement(n.h3,null,"安装WiFi 蓝牙固件"),"\n",l.createElement(n.p,null,"root #emerge sys-kernel/linux-firmware"),"\n",l.createElement(n.p,null,"对于树莓派内置的 Wi-Fi 驱动程序brcmfmac会需要二进制固件 blob brcmfmac434*-sdio.bin。因此我们可能要配置一下brcmfmac434*-sdio.txt才能正常运行。"),"\n",l.createElement(n.p,null,"对于蓝牙，我们需要BCM43430A1.hcd 这个文件来支持运行。我们可以在树莓派官网蓝牙固件处找到，最后只需要将其配置到/lib/firmware/brcm处"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-shell"},"\troot #mkdir -p /lib/firmware/brcm\n\troot #wget -P /lib/firmware/brcm https://raw.githubusercontent.com/RPi-Distro/bluez-firmware/master/broadcom/BCM4345C0.hcd\n")),"\n",l.createElement(n.h3,null,"VideoCore4"),"\n",l.createElement(n.p,null,"要在 RPi 设备上启用 VideoCore4 GPU 加速，请将以下内容添加到/boot/config.txt："),"\n",l.createElement(n.p,null,"/boot/config.txt\ndtoverlay = vc4-kms-v3d,cma-128"),"\n",l.createElement(n.p,null,"最后还要在我们的make.conf添加:"),"\n",l.createElement(n.p,null,'VIDEO_CARDS = "vc4"'),"\n",l.createElement(n.hr),"\n",l.createElement("a",{align:"center",color:"#F2ABBD",width:"100%",textAlign:"center",paddingBottom:"0.5rem",paddingTop:"0.5rem"},l.createElement(n.p,null,l.createElement(n.a,{href:"../"},"Go Back")),l.createElement("p",null,l.createElement(n.p,null,"Projects by"," "),l.createElement("a",{href:"https://github.com/ottoqwq"}," ",l.createElement("hi",null,"Otto Deng")),l.createElement(n.p,null,". Powered by ",l.createElement("a",{href:"https://www.gatsbyjs.com/"},"Gatsby"))),l.createElement("p",null,l.createElement(n.p,null,"Content on this site is licensed under"," ","\n",l.createElement("a",{href:"https://creativecommons.org/licenses/by/4.0/"},"CC BY 4.0")," ","\nunless specified."))))}n.default=function(e){return void 0===e&&(e={}),l.createElement(a,e,l.createElement(o,e))}},1151:function(e,n,t){t.d(n,{ah:function(){return a}});var r=t(7294);const l=r.createContext({});function a(e){const n=r.useContext(l);return r.useMemo((()=>"function"==typeof e?e(n):{...n,...e}),[n,e])}}}]);
//# sourceMappingURL=component---src-pages-blog-2022-1-2-gentoo-on-rpi-4-mdx-c58a6ef8326eb83542b8.js.map